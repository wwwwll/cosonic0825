// alignment_debug_test.rs - åˆåƒæ£€æµ‹è°ƒè¯•æµ‹è¯•ç¨‹åº
// ä¸“é—¨ç”¨äºè°ƒè¯•åœ†ç‚¹æ£€æµ‹é—®é¢˜ï¼Œä½¿ç”¨æœ¬åœ°ä¿å­˜çš„å›¾åƒè¿›è¡Œç¦»çº¿æµ‹è¯•

use std::time::Instant;
use std::path::Path;
use opencv::{core, imgcodecs, imgproc, prelude::*};
use merging_image_lib::modules::alignment::AlignmentSystem;
use opencv::core::AlgorithmHint;

/// åˆåƒæ£€æµ‹è°ƒè¯•æµ‹è¯•å™¨
pub struct AlignmentDebugTest {
    alignment_system: Option<AlignmentSystem>,
    test_image_left: core::Mat,
    test_image_right: core::Mat,
    rectify_maps_path: String,
}

impl AlignmentDebugTest {
    /// åˆ›å»ºè°ƒè¯•æµ‹è¯•å™¨å®ä¾‹
    pub fn new() -> Result<Self, Box<dyn std::error::Error>> {
        println!("ğŸ”§ åˆå§‹åŒ–åˆåƒæ£€æµ‹è°ƒè¯•æµ‹è¯•å™¨...");
        
        // ç¡®å®šæ­£ç¡®çš„æ–‡ä»¶è·¯å¾„
        let exe_path = std::env::current_exe()?;
        let exe_dir = exe_path.parent().unwrap();
        let src_tauri_dir = exe_dir.parent().unwrap().parent().unwrap();
        
        println!("ğŸ“ é¡¹ç›®æ ¹ç›®å½•: {:?}", src_tauri_dir);
        
        // æ„é€ ç»å¯¹è·¯å¾„
        let img_path_left = src_tauri_dir.join("src/tests/data/benchmark/left_calibration.bmp");
        let img_path_right = src_tauri_dir.join("src/tests/data/benchmark/right_calibration.bmp");
        // ğŸ”§ ä¿®æ­£é‡æ˜ å°„çŸ©é˜µè·¯å¾„ - ä½¿ç”¨yaml_last_param_fileç›®å½•
        let rectify_maps = src_tauri_dir.join("yaml_last_param_file/rectify_maps.yaml");
        
        // éªŒè¯æ–‡ä»¶å­˜åœ¨
        if !img_path_left.exists() {
            return Err(format!("å·¦å›¾åƒæ–‡ä»¶ä¸å­˜åœ¨: {:?}", img_path_left).into());
        }
        if !img_path_right.exists() {
            return Err(format!("å³å›¾åƒæ–‡ä»¶ä¸å­˜åœ¨: {:?}", img_path_right).into());
        }
        if !rectify_maps.exists() {
            return Err(format!("é‡æ˜ å°„æ–‡ä»¶ä¸å­˜åœ¨: {:?}", rectify_maps).into());
        }
        
        // åŠ è½½æµ‹è¯•å›¾åƒ
        println!("ğŸ“ åŠ è½½æµ‹è¯•å›¾åƒ...");
        println!("   å·¦å›¾åƒ: {:?}", img_path_left);
        println!("   å³å›¾åƒ: {:?}", img_path_right);
        
        let test_image_left = imgcodecs::imread(
            img_path_left.to_str().unwrap(),
            imgcodecs::IMREAD_GRAYSCALE
        )?;
        
        let test_image_right = imgcodecs::imread(
            img_path_right.to_str().unwrap(),
            imgcodecs::IMREAD_GRAYSCALE
        )?;
        
        if test_image_left.empty() || test_image_right.empty() {
            return Err("æ— æ³•åŠ è½½æµ‹è¯•å›¾åƒï¼Œè¯·æ£€æŸ¥æ–‡ä»¶æ ¼å¼".into());
        }
        
        let image_size = test_image_left.size()?;
        println!("âœ“ æµ‹è¯•å›¾åƒåŠ è½½æˆåŠŸ: {}Ã—{}", image_size.width, image_size.height);
        
        // æ‰“å°å›¾åƒåŸºæœ¬ä¿¡æ¯
        println!("ğŸ“Š å›¾åƒä¿¡æ¯:");
        println!("   å·¦å›¾: å°ºå¯¸={}Ã—{}, ç±»å‹={}, é€šé“={}", 
                test_image_left.cols(), test_image_left.rows(), 
                test_image_left.typ(), test_image_left.channels());
        println!("   å³å›¾: å°ºå¯¸={}Ã—{}, ç±»å‹={}, é€šé“={}", 
                test_image_right.cols(), test_image_right.rows(), 
                test_image_right.typ(), test_image_right.channels());
        
        // æ£€æŸ¥å›¾åƒç°åº¦èŒƒå›´
        let mut min_val = 0.0;
        let mut max_val = 0.0;
        core::min_max_loc(
            &test_image_left,
            Some(&mut min_val),
            Some(&mut max_val),
            None,
            None,
            &core::no_array(),
        )?;
        println!("   å·¦å›¾ç°åº¦èŒƒå›´: [{:.0}, {:.0}]", min_val, max_val);
        
        core::min_max_loc(
            &test_image_right,
            Some(&mut min_val),
            Some(&mut max_val),
            None,
            None,
            &core::no_array(),
        )?;
        println!("   å³å›¾ç°åº¦èŒƒå›´: [{:.0}, {:.0}]", min_val, max_val);
        
        Ok(Self {
            alignment_system: None,
            test_image_left,
            test_image_right,
            rectify_maps_path: rectify_maps.to_string_lossy().to_string(),
        })
    }
    
    /// åˆå§‹åŒ–åˆåƒæ£€æµ‹ç³»ç»Ÿ
    fn init_alignment_system(&mut self) -> Result<(), Box<dyn std::error::Error>> {
        if self.alignment_system.is_some() {
            return Ok(());
        }
        
        println!("ğŸš€ åˆå§‹åŒ–åˆåƒæ£€æµ‹ç³»ç»Ÿ...");
        
        let exe_path = std::env::current_exe()?;
        let exe_dir = exe_path.parent().unwrap();
        let src_tauri_dir = exe_dir.parent().unwrap().parent().unwrap();
        
        // ğŸ”§ ä¿®æ­£å‚æ•°æ–‡ä»¶è·¯å¾„ - ä½¿ç”¨yaml_last_param_fileç›®å½•
        // æ—§è·¯å¾„ (æ³¨é‡Šæ‰):
        // let left_cam_params = src_tauri_dir.join("left_camera_params.yaml");
        // let right_cam_params = src_tauri_dir.join("right_camera_params.yaml");
        // let stereo_params = src_tauri_dir.join("stereo_params.yaml");
        // let rectify_params = src_tauri_dir.join("rectify_params.yaml");
        
        let left_cam_params = src_tauri_dir.join("yaml_last_param_file/left_camera_params.yaml");
        let right_cam_params = src_tauri_dir.join("yaml_last_param_file/right_camera_params.yaml");
        let stereo_params = src_tauri_dir.join("yaml_last_param_file/stereo_params.yaml");
        let rectify_params = src_tauri_dir.join("yaml_last_param_file/rectify_params.yaml");
        
        // æ£€æŸ¥æ ‡å®šæ–‡ä»¶æ˜¯å¦å­˜åœ¨
        let required_files = [
            ("å·¦ç›¸æœºå‚æ•°", &left_cam_params),
            ("å³ç›¸æœºå‚æ•°", &right_cam_params),
            ("åŒç›®å‚æ•°", &stereo_params),
            ("æ ¡æ­£å‚æ•°", &rectify_params),
        ];
        
        for (name, path) in &required_files {
            if !path.exists() {
                return Err(format!("{}æ–‡ä»¶ä¸å­˜åœ¨: {:?}", name, path).into());
            }
            println!("   âœ“ {}: {:?}", name, path);
        }
        
        let image_size = self.test_image_left.size()?;
        
        // ä½¿ç”¨é¢„åŠ è½½ç‰ˆæœ¬åˆ›å»ºç³»ç»Ÿ
        let alignment_system = AlignmentSystem::new_with_preload(
            image_size,
            left_cam_params.to_str().unwrap(),
            right_cam_params.to_str().unwrap(),
            stereo_params.to_str().unwrap(),
            rectify_params.to_str().unwrap(),
            &self.rectify_maps_path,
        )?;
        
        self.alignment_system = Some(alignment_system);
        println!("âœ“ åˆåƒæ£€æµ‹ç³»ç»Ÿåˆå§‹åŒ–å®Œæˆ");
        
        Ok(())
    }
    
    /// è¿è¡Œæ‰€æœ‰è°ƒè¯•æµ‹è¯•
    pub fn run_debug_tests(&mut self) -> Result<(), Box<dyn std::error::Error>> {
        println!("\nğŸš€ å¼€å§‹åˆåƒæ£€æµ‹è°ƒè¯•æµ‹è¯•");
        println!("{}", "=".repeat(60));
        
        // 1. æµ‹è¯•å›¾åƒåŸºæœ¬ä¿¡æ¯
        self.test_image_info()?;
        
        // 2. åˆå§‹åŒ–ç³»ç»Ÿ
        self.init_alignment_system()?;
        
        // 3. æµ‹è¯•åœ†ç‚¹æ£€æµ‹
        self.test_circle_detection()?;
        
        // 4. æµ‹è¯•å®Œæ•´æ£€æµ‹æµç¨‹
        self.test_complete_alignment()?;
        
        // 5. ä¿å­˜è°ƒè¯•å›¾åƒ
        self.save_debug_images()?;
        
        println!("\nğŸ‰ è°ƒè¯•æµ‹è¯•å®Œæˆ");
        Ok(())
    }
    
    /// æµ‹è¯•å›¾åƒåŸºæœ¬ä¿¡æ¯
    fn test_image_info(&self) -> Result<(), Box<dyn std::error::Error>> {
        println!("\nğŸ“Š æµ‹è¯•1: å›¾åƒåŸºæœ¬ä¿¡æ¯åˆ†æ");
        println!("{}", "-".repeat(40));
        
        // ä¿å­˜åŸå§‹å›¾åƒå‰¯æœ¬ç”¨äºåˆ†æ
        imgcodecs::imwrite("debug_left_original.png", &self.test_image_left, &core::Vector::<i32>::new())?;
        imgcodecs::imwrite("debug_right_original.png", &self.test_image_right, &core::Vector::<i32>::new())?;
        println!("âœ“ å·²ä¿å­˜åŸå§‹å›¾åƒ: debug_left_original.png, debug_right_original.png");
        
        // è·³è¿‡å¤æ‚çš„ç›´æ–¹å›¾è®¡ç®—ï¼Œä¸“æ³¨äºåœ†ç‚¹æ£€æµ‹è°ƒè¯•
        println!("âœ“ å›¾åƒåŸºæœ¬ä¿¡æ¯åˆ†æå®Œæˆ");
        
        // æ£€æŸ¥å›¾åƒæ˜¯å¦æœ‰è¶³å¤Ÿçš„å¯¹æ¯”åº¦
        let mut mean_val = core::Scalar::default();
        let mut std_dev = core::Scalar::default();
        core::mean_std_dev(&self.test_image_left, &mut mean_val, &mut std_dev, &core::no_array())?;
        
        println!("ğŸ“ˆ å·¦å›¾åƒç»Ÿè®¡:");
        println!("   å¹³å‡å€¼: {:.2}", mean_val[0]);
        println!("   æ ‡å‡†å·®: {:.2}", std_dev[0]);
        
        if std_dev[0] < 20.0 {
            println!("âš ï¸ è­¦å‘Š: å›¾åƒå¯¹æ¯”åº¦è¾ƒä½ (æ ‡å‡†å·®={:.2}), å¯èƒ½å½±å“åœ†ç‚¹æ£€æµ‹", std_dev[0]);
        } else {
            println!("âœ“ å›¾åƒå¯¹æ¯”åº¦è‰¯å¥½ (æ ‡å‡†å·®={:.2})", std_dev[0]);
        }
        
        Ok(())
    }
    
    /// æµ‹è¯•åœ†ç‚¹æ£€æµ‹
    fn test_circle_detection(&mut self) -> Result<(), Box<dyn std::error::Error>> {
        println!("\nğŸ” æµ‹è¯•2: åœ†ç‚¹æ£€æµ‹æµ‹è¯•");
        println!("{}", "-".repeat(40));
        
        let alignment_system = self.alignment_system.as_mut().unwrap();
        
        // æµ‹è¯•åœ†ç‚¹æ£€æµ‹
        let start_time = Instant::now();
        let detection_result = alignment_system.detect_circles_grid(
            &self.test_image_left,
            &self.test_image_right,
            &self.rectify_maps_path,
        );
        let detection_time = start_time.elapsed();
        
        match detection_result {
            Ok((corners_left, corners_right)) => {
                println!("âœ… åœ†ç‚¹æ£€æµ‹æˆåŠŸ!");
                println!("   å·¦çœ¼æ£€æµ‹åˆ°: {} ä¸ªåœ†ç‚¹", corners_left.len());
                println!("   å³çœ¼æ£€æµ‹åˆ°: {} ä¸ªåœ†ç‚¹", corners_right.len());
                println!("   æ£€æµ‹è€—æ—¶: {:.1} ms", detection_time.as_millis());
                
                // éªŒè¯åœ†ç‚¹æ•°é‡
                if corners_left.len() == 40 && corners_right.len() == 40 {
                    println!("âœ“ åœ†ç‚¹æ•°é‡æ­£ç¡® (æœŸæœ›40ä¸ª)");
                } else {
                    println!("âš ï¸ åœ†ç‚¹æ•°é‡å¼‚å¸¸ (æœŸæœ›40ä¸ª, å®é™…å·¦çœ¼{}ä¸ª, å³çœ¼{}ä¸ª)", 
                            corners_left.len(), corners_right.len());
                }
                
                // æ‰“å°éƒ¨åˆ†åœ†ç‚¹åæ ‡ç”¨äºéªŒè¯
                println!("ğŸ“ å·¦çœ¼å‰5ä¸ªåœ†ç‚¹åæ ‡:");
                for i in 0..std::cmp::min(5, corners_left.len()) {
                    let point = corners_left.get(i)?;
                    println!("   ç‚¹{}: ({:.2}, {:.2})", i, point.x, point.y);
                }
                
            }
            Err(e) => {
                println!("âŒ åœ†ç‚¹æ£€æµ‹å¤±è´¥: {}", e);
                
                // å°è¯•åˆ†æå¤±è´¥åŸå› 
                println!("\nğŸ” å¤±è´¥åŸå› åˆ†æ:");
                
                // 1. æ£€æŸ¥SimpleBlobDetectorå‚æ•°
                println!("1. æµ‹è¯•SimpleBlobDetectorå‚æ•°...");
                let detector = alignment_system.create_optimized_blob_detector()?;
                println!("   âœ“ SimpleBlobDetectoråˆ›å»ºæˆåŠŸ");
                
                // 2. æµ‹è¯•å•ç‹¬çš„å›¾åƒæ£€æµ‹
                println!("2. æµ‹è¯•å•ç‹¬å›¾åƒæ£€æµ‹...");
                self.test_individual_image_detection()?;
                
                return Err(format!("åœ†ç‚¹æ£€æµ‹å¤±è´¥: {}", e).into());
            }
        }
        
        Ok(())
    }
    
    /// æµ‹è¯•å•ç‹¬çš„å›¾åƒæ£€æµ‹
    fn test_individual_image_detection(&mut self) -> Result<(), Box<dyn std::error::Error>> {
        let alignment_system = self.alignment_system.as_mut().unwrap();
        
        // ç›´æ¥åœ¨åŸå§‹å›¾åƒä¸Šæµ‹è¯•æ£€æµ‹
        let pattern_size = core::Size::new(4, 10);
        let mut corners = core::Vector::<core::Point2f>::new();
        let detector = alignment_system.create_optimized_blob_detector()?;
        
        println!("   æµ‹è¯•å·¦å›¾åŸå§‹æ£€æµ‹...");
        let found = alignment_system.detect_circles_full_image(
            &self.test_image_left,
            pattern_size,
            &mut corners,
            &detector,
        )?;
        
        if found {
            println!("   âœ“ å·¦å›¾åŸå§‹æ£€æµ‹æˆåŠŸ: {} ä¸ªåœ†ç‚¹", corners.len());
        } else {
            println!("   âŒ å·¦å›¾åŸå§‹æ£€æµ‹å¤±è´¥");
            
            // å°è¯•ä¿å­˜å¸¦æ£€æµ‹ç»“æœçš„å›¾åƒ
            let mut debug_img = self.test_image_left.clone();
            if debug_img.channels() == 1 {
                imgproc::cvt_color(&self.test_image_left, &mut debug_img, imgproc::COLOR_GRAY2BGR, 0, AlgorithmHint::ALGO_HINT_DEFAULT)?;
            }
            
            // å°è¯•ä½¿ç”¨ä¸åŒçš„æ£€æµ‹å‚æ•°
            self.try_different_detection_params(&self.test_image_left)?;
        }
        
        Ok(())
    }
    
    /// å°è¯•ä¸åŒçš„æ£€æµ‹å‚æ•°
    fn try_different_detection_params(&self, image: &core::Mat) -> Result<(), Box<dyn std::error::Error>> {
        println!("   ğŸ”§ å°è¯•ä¸åŒçš„SimpleBlobDetectorå‚æ•°...");
        
        // å‚æ•°ç»„åˆ1: æ›´å®½æ¾çš„å‚æ•°
        let mut params1 = opencv::features2d::SimpleBlobDetector_Params::default()?;
        params1.min_threshold = 50.0;
        params1.max_threshold = 220.0;
        params1.threshold_step = 10.0;
        params1.filter_by_area = true;
        params1.min_area = 50.0;
        params1.max_area = 10000.0;
        params1.filter_by_circularity = false;
        params1.filter_by_convexity = false;
        params1.filter_by_inertia = false;
        
        let detector1 = opencv::features2d::SimpleBlobDetector::create(params1)?;
        let mut corners1 = core::Vector::<core::Point2f>::new();
        let found1 = opencv::calib3d::find_circles_grid(
            image,
            core::Size::new(4, 10),
            &mut corners1,
            opencv::calib3d::CALIB_CB_ASYMMETRIC_GRID,
            Some(&detector1.into()),
            opencv::calib3d::CirclesGridFinderParameters::default()?,
        )?;
        
        println!("     å‚æ•°ç»„1 (å®½æ¾): {} - {} ä¸ªåœ†ç‚¹", 
                if found1 { "æˆåŠŸ" } else { "å¤±è´¥" }, corners1.len());
        
        // å‚æ•°ç»„åˆ2: æ›´ä¸¥æ ¼çš„å‚æ•°
        let mut params2 = opencv::features2d::SimpleBlobDetector_Params::default()?;
        params2.min_threshold = 100.0;
        params2.max_threshold = 200.0;
        params2.threshold_step = 50.0;
        params2.filter_by_area = true;
        params2.min_area = 200.0;
        params2.max_area = 5000.0;
        params2.filter_by_circularity = true;
        params2.min_circularity = 0.8;
        params2.filter_by_convexity = false;
        params2.filter_by_inertia = false;
        
        let detector2 = opencv::features2d::SimpleBlobDetector::create(params2)?;
        let mut corners2 = core::Vector::<core::Point2f>::new();
        let found2 = opencv::calib3d::find_circles_grid(
            image,
            core::Size::new(4, 10),
            &mut corners2,
            opencv::calib3d::CALIB_CB_ASYMMETRIC_GRID,
            Some(&detector2.into()),
            opencv::calib3d::CirclesGridFinderParameters::default()?,
        )?;
        
        println!("     å‚æ•°ç»„2 (ä¸¥æ ¼): {} - {} ä¸ªåœ†ç‚¹", 
                if found2 { "æˆåŠŸ" } else { "å¤±è´¥" }, corners2.len());
        
        // å‚æ•°ç»„åˆ3: é»˜è®¤å‚æ•°
        let params3 = opencv::features2d::SimpleBlobDetector_Params::default()?;
        let detector3 = opencv::features2d::SimpleBlobDetector::create(params3)?;
        let mut corners3 = core::Vector::<core::Point2f>::new();
        let found3 = opencv::calib3d::find_circles_grid(
            image,
            core::Size::new(4, 10),
            &mut corners3,
            opencv::calib3d::CALIB_CB_ASYMMETRIC_GRID,
            Some(&detector3.into()),
            opencv::calib3d::CirclesGridFinderParameters::default()?,
        )?;
        
        println!("     å‚æ•°ç»„3 (é»˜è®¤): {} - {} ä¸ªåœ†ç‚¹", 
                if found3 { "æˆåŠŸ" } else { "å¤±è´¥" }, corners3.len());
        
        Ok(())
    }
    
    /// æµ‹è¯•å®Œæ•´çš„åˆåƒæ£€æµ‹æµç¨‹
    fn test_complete_alignment(&mut self) -> Result<(), Box<dyn std::error::Error>> {
        println!("\nğŸ¯ æµ‹è¯•3: å®Œæ•´åˆåƒæ£€æµ‹æµç¨‹");
        println!("{}", "-".repeat(40));
        
        let alignment_system = self.alignment_system.as_mut().unwrap();
        
        // é¦–å…ˆè¿›è¡Œåœ†ç‚¹æ£€æµ‹
        let detection_result = alignment_system.detect_circles_grid(
            &self.test_image_left,
            &self.test_image_right,
            &self.rectify_maps_path,
        );
        
        match detection_result {
            Ok((corners_left, corners_right)) => {
                println!("âœ“ åœ†ç‚¹æ£€æµ‹æˆåŠŸï¼Œå¼€å§‹å§¿æ€å’Œåˆåƒåˆ†æ...");
                
                // æµ‹è¯•å·¦çœ¼å§¿æ€æ£€æµ‹
                let left_pose = alignment_system.check_left_eye_pose(&corners_left)?;
                println!("ğŸ“Š å·¦çœ¼å§¿æ€: roll={:.3}Â°, pitch={:.3}Â°, yaw={:.3}Â°, é€šè¿‡={}", 
                        left_pose.roll, left_pose.pitch, left_pose.yaw, left_pose.pass);
                
                // æµ‹è¯•å³çœ¼å§¿æ€æ£€æµ‹
                let right_pose = alignment_system.check_right_eye_pose(&corners_right)?;
                println!("ğŸ“Š å³çœ¼å§¿æ€: roll={:.3}Â°, pitch={:.3}Â°, yaw={:.3}Â°, é€šè¿‡={}", 
                        right_pose.roll, right_pose.pitch, right_pose.yaw, right_pose.pass);
                
                // æµ‹è¯•å·¦çœ¼å±…ä¸­æ£€æµ‹
                let centering = alignment_system.check_left_eye_centering(&corners_left, None)?;
                println!("ğŸ“Š å·¦çœ¼å±…ä¸­: å±…ä¸­={}, æœ€å¤§åç§»={:.1}px, å®¹å·®={:.1}px", 
                        centering.is_centered, centering.max_offset_distance, centering.tolerance_px);
                
                // æµ‹è¯•åŒçœ¼åˆåƒæ£€æµ‹
                if left_pose.pass && right_pose.pass {
                    let alignment = alignment_system.check_dual_eye_alignment(
                        &corners_left, &corners_right, true
                    )?;
                    println!("ğŸ“Š åŒçœ¼åˆåƒ: RMS={:.3}px, P95={:.3}px, Max={:.3}px, é€šè¿‡={}", 
                            alignment.rms, alignment.p95, alignment.max_err, alignment.pass);
                } else {
                    println!("âš ï¸ å§¿æ€æ£€æµ‹æœªé€šè¿‡ï¼Œè·³è¿‡åˆåƒåˆ†æ");
                }
                
                // æµ‹è¯•è°ƒæ•´å‘é‡è®¡ç®—
                let adjustment = alignment_system.calculate_adjustment_vectors(
                    Some(&left_pose),
                    Some(&centering),
                    Some(&right_pose),
                    None,
                );
                println!("ğŸ“Š è°ƒæ•´ä¼˜å…ˆçº§: {:?}", adjustment.priority);
                
                println!("âœ… å®Œæ•´æ£€æµ‹æµç¨‹æµ‹è¯•æˆåŠŸ!");
                
            }
            Err(e) => {
                println!("âŒ å®Œæ•´æµç¨‹æµ‹è¯•å¤±è´¥: {}", e);
                return Err(e);
            }
        }
        
        Ok(())
    }
    
    /// ä¿å­˜è°ƒè¯•å›¾åƒ
    fn save_debug_images(&self) -> Result<(), Box<dyn std::error::Error>> {
        println!("\nğŸ’¾ æµ‹è¯•4: ä¿å­˜è°ƒè¯•å›¾åƒ");
        println!("{}", "-".repeat(40));
        
        // ä¿å­˜å¤„ç†åçš„å›¾åƒç”¨äºæ‰‹åŠ¨æ£€æŸ¥
        imgcodecs::imwrite("debug_left_processed.png", &self.test_image_left, &core::Vector::<i32>::new())?;
        imgcodecs::imwrite("debug_right_processed.png", &self.test_image_right, &core::Vector::<i32>::new())?;
        
        println!("âœ“ è°ƒè¯•å›¾åƒå·²ä¿å­˜:");
        println!("   - debug_left_original.png (å·¦å›¾åŸå§‹)");
        println!("   - debug_right_original.png (å³å›¾åŸå§‹)");
        println!("   - debug_left_processed.png (å·¦å›¾å¤„ç†å)");
        println!("   - debug_right_processed.png (å³å›¾å¤„ç†å)");
        
        // å¦‚æœå­˜åœ¨alignment_debug.pngï¼Œä¹ŸæŠ¥å‘Š
        if Path::new("alignment_debug.png").exists() {
            println!("   - alignment_debug.png (åˆåƒåˆ†æç»“æœ)");
        }
        
        Ok(())
    }
}

fn main() -> Result<(), Box<dyn std::error::Error>> {
    println!("ğŸš€ å¯åŠ¨åˆåƒæ£€æµ‹è°ƒè¯•æµ‹è¯•ç¨‹åº");
    
    let mut test = AlignmentDebugTest::new()?;
    test.run_debug_tests()?;
    
    println!("\nğŸ‰ è°ƒè¯•æµ‹è¯•ç¨‹åºå®Œæˆ");
    println!("è¯·æ£€æŸ¥ç”Ÿæˆçš„è°ƒè¯•å›¾åƒæ–‡ä»¶ï¼Œåˆ†æåœ†ç‚¹æ£€æµ‹é—®é¢˜");
    
    Ok(())
} 