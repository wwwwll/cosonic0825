//! ç›¸æœºè¯Šæ–­ç¨‹åº - æ£€æŸ¥å›¾åƒå°ºå¯¸å’Œæ ‡å®šæ¿æ£€æµ‹
//! 
//! ç”¨äºè¯Šæ–­æ ‡å®šæ¿æ£€æµ‹å¤±è´¥çš„é—®é¢˜

use merging_image_lib::camera_manager::SimpleCameraManager;
use opencv::{core::Size, imgcodecs, imgproc, prelude::*};

fn main() {
    println!("ğŸ” ç›¸æœºè¯Šæ–­ç¨‹åº");
    println!("================");
    
    // 1. æ£€æŸ¥SimpleCameraManager
    println!("\nğŸ“· æ£€æŸ¥SimpleCameraManager...");
    let mut camera_manager = match SimpleCameraManager::new() {
        Ok(cm) => {
            println!("âœ… SimpleCameraManageråˆå§‹åŒ–æˆåŠŸ");
            cm
        },
        Err(e) => {
            println!("âŒ SimpleCameraManageråˆå§‹åŒ–å¤±è´¥: {}", e);
            return;
        }
    };
    
    // 2. å¯åŠ¨ç›¸æœºå¹¶è·å–ä¸€å¸§
    println!("\nğŸ“¸ å¯åŠ¨ç›¸æœºå¹¶è·å–æµ‹è¯•å¸§...");
    if let Err(e) = camera_manager.start() {
        println!("âŒ å¯åŠ¨ç›¸æœºå¤±è´¥: {}", e);
        return;
    }
    
    let (left_data, right_data) = match camera_manager.capture_and_process(false) {
        Ok(data) => {
            println!("âœ… è·å–å›¾åƒæ•°æ®æˆåŠŸ");
            println!("   å·¦å›¾æ•°æ®å¤§å°: {} bytes", data.0.len());
            println!("   å³å›¾æ•°æ®å¤§å°: {} bytes", data.1.len());
            data
        },
        Err(e) => {
            println!("âŒ è·å–å›¾åƒæ•°æ®å¤±è´¥: {}", e);
            let _ = camera_manager.stop();
            return;
        }
    };
    
    // 3. åˆ†æå›¾åƒæ•°æ®
    println!("\nğŸ” åˆ†æå›¾åƒæ•°æ®...");
    analyze_image_data("å·¦å›¾", &left_data);
    analyze_image_data("å³å›¾", &right_data);
    
    // 4. å°è¯•ä¸åŒçš„å›¾åƒå°ºå¯¸è½¬æ¢
    println!("\nğŸ§ª å°è¯•ä¸åŒçš„å›¾åƒå°ºå¯¸è½¬æ¢...");
    test_different_dimensions(&left_data);
    
    // 5. åœæ­¢ç›¸æœº
    let _ = camera_manager.stop();
    println!("\nâœ… è¯Šæ–­å®Œæˆ");
}

fn analyze_image_data(name: &str, data: &[u8]) {
    println!("  ğŸ“Š {}:", name);
    println!("     æ•°æ®é•¿åº¦: {} bytes", data.len());
    
    // å°è¯•æ¨æ–­å¯èƒ½çš„å›¾åƒå°ºå¯¸
    let possible_sizes = vec![
        (2448, 2048, "å…¨åˆ†è¾¨ç‡"),
        (1224, 1024, "1/2åˆ†è¾¨ç‡"),
        (612, 512, "1/4åˆ†è¾¨ç‡"),
        (2048, 2448, "æ—‹è½¬90åº¦"),
        (1920, 1080, "1080p"),
        (1280, 720, "720p"),
    ];
    
    println!("     å¯èƒ½çš„å°ºå¯¸:");
    for (w, h, desc) in possible_sizes {
        let expected_size = w * h;
        if expected_size == data.len() {
            println!("       âœ… {}x{} ({}) - åŒ¹é…!", w, h, desc);
        } else {
            println!("       âŒ {}x{} ({}) - æœŸæœ›{}, å®é™…{}", w, h, desc, expected_size, data.len());
        }
    }
}

fn test_different_dimensions(data: &[u8]) {
    // æ ¹æ®æ•°æ®å¤§å°æ¨æ–­æœ€å¯èƒ½çš„å°ºå¯¸
    let data_len = data.len();
    
    // å¸¸è§çš„ç›¸æœºåˆ†è¾¨ç‡
    let test_dimensions = vec![
        (2448i32, 2048i32),
        (1224i32, 1024i32), 
        (612i32, 512i32),
        (2048i32, 2448i32),
    ];
    
    for (width, height) in test_dimensions {
        let expected_size = (width * height) as usize;
        if expected_size == data_len {
            println!("  ğŸ¯ æµ‹è¯•å°ºå¯¸ {}x{}", width, height);
            
            match raw_data_to_mat(data, width, height) {
                Ok(mat) => {
                    println!("    âœ… Matåˆ›å»ºæˆåŠŸ: {}x{}", mat.cols(), mat.rows());
                    
                    // ä¿å­˜æµ‹è¯•å›¾åƒ
                    let test_path = format!("test_image_{}x{}.png", width, height);
                    if imgcodecs::imwrite(&test_path, &mat, &opencv::core::Vector::new()).is_ok() {
                        println!("    âœ… æµ‹è¯•å›¾åƒå·²ä¿å­˜: {}", test_path);
                        
                        // å°è¯•æ ‡å®šæ¿æ£€æµ‹
                        test_calibration_detection(&mat, width, height);
                    }
                },
                Err(e) => {
                    println!("    âŒ Matåˆ›å»ºå¤±è´¥: {}", e);
                }
            }
        }
    }
}

fn raw_data_to_mat(image_data: &[u8], width: i32, height: i32) -> Result<opencv::core::Mat, String> {
    use opencv::core::{Mat, CV_8UC1, Scalar};
    
    let expected_size = (width * height) as usize;
    if image_data.len() != expected_size {
        return Err(format!("æ•°æ®å¤§å°ä¸åŒ¹é…: æœŸæœ› {} å­—èŠ‚ï¼Œå®é™… {} å­—èŠ‚", 
            expected_size, image_data.len()));
    }
    
    let mut mat = Mat::new_rows_cols_with_default(height, width, CV_8UC1, Scalar::all(0.0))
        .map_err(|e| format!("åˆ›å»ºMatå¤±è´¥: {}", e))?;
    
    unsafe {
        let mat_data = mat.ptr_mut(0).map_err(|e| format!("è·å–MatæŒ‡é’ˆå¤±è´¥: {}", e))?;
        std::ptr::copy_nonoverlapping(image_data.as_ptr(), mat_data, image_data.len());
    }
    
    Ok(mat)
}

fn test_calibration_detection(mat: &opencv::core::Mat, width: i32, height: i32) {
    use merging_image_lib::modules::calibration_circles::Calibrator;
    
    println!("    ğŸ” æµ‹è¯•æ ‡å®šæ¿æ£€æµ‹...");
    
    let mut calibrator = match Calibrator::new(
        Size::new(width, height),
        15.0,    // circle_diameter
        25.0,   // center_distance  
        Size::new(10, 4), // pattern_size
        2.0,    // error_threshold
    ) {
        Ok(c) => c,
        Err(e) => {
            println!("    âŒ åˆ›å»ºæ ‡å®šå™¨å¤±è´¥: {}", e);
            return;
        }
    };
    
    let detected = calibrator.quick_detect_calibration_pattern(mat);
    println!("    {} æ ‡å®šæ¿æ£€æµ‹ç»“æœ: {}", 
        if detected { "âœ…" } else { "âŒ" }, detected);
    
    if !detected {
        println!("    ğŸ’¡ å»ºè®®æ£€æŸ¥:");
        println!("       - æ ‡å®šæ¿æ˜¯å¦åœ¨è§†é‡å†…");
        println!("       - å…‰ç…§æ˜¯å¦å……è¶³");
        println!("       - å›¾åƒæ˜¯å¦æ¸…æ™°");
        println!("       - æ ‡å®šæ¿è§„æ ¼æ˜¯å¦ä¸º10x4 asymmetric circles");
    }
} 