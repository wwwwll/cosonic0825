// connected_components_circle_detection_test.rs - è¿é€šåŸŸåœ†ç‚¹æ£€æµ‹æµ‹è¯•
// æ›¿æ¢SimpleBlobDetectorï¼Œä½¿ç”¨è¿é€šåŸŸ+é¢ç§¯è¿‡æ»¤å®ç°æ›´å¿«é€Ÿã€ç²¾ç¡®çš„åœ†ç‚¹æ£€æµ‹

use std::path::Path;
use std::time::Instant;
use opencv::{core, imgcodecs, imgproc, prelude::*};

/// ğŸ¨ V3: åœ†å¿ƒç»†åŒ–æ¥æºæ ‡è®°ï¼ˆç”¨äºdebugå¯è§†åŒ–ï¼‰
#[derive(Copy, Clone)]
enum RefineTag { 
    Hi,       // é«˜ç½®ä¿¡ï¼ˆDT-onlyï¼‰
    Lo,       // ä½ç½®ä¿¡ï¼ˆå¾„å‘é‡‡æ ·+è½»é‡åœ†æ‹Ÿåˆï¼‰
    Fallback  // å›é€€åˆ°åŸåæ ‡
}

/// ğŸš€ V3: é¢„è®¡ç®—æ©è†œï¼ˆä¸€æ¬¡ç”Ÿæˆï¼Œå¤šæ¬¡å¤ç”¨ï¼‰
struct PrecomputedMasks {
    inner_mask_u8: core::Mat,
    ring_mask_u8: core::Mat,
    center_template: core::Mat, // ä¸­å¿ƒå°åœ†æ¨¡æ¿ç”¨äºDTå³°å€¼æœç´¢
}

impl PrecomputedMasks {
    fn new(roi_side: i32, rin: f32, rout: f32) -> Result<Self, opencv::Error> {
        let mut inner = core::Mat::zeros(roi_side, roi_side, core::CV_8U)?.to_mat()?;
        let mut ring = inner.try_clone()?;
        let c = core::Point::new(roi_side / 2, roi_side / 2);
        
        // å†…ç›˜æ©è†œ
        imgproc::circle(&mut inner, c, rin as i32, core::Scalar::all(255.0), -1, imgproc::LINE_8, 0)?;
        
        // ç¯åŸŸæ©è†œ
        imgproc::circle(&mut ring, c, rout as i32, core::Scalar::all(255.0), -1, imgproc::LINE_8, 0)?;
        imgproc::circle(&mut ring, c, (rin * 1.3) as i32, core::Scalar::all(0.0), -1, imgproc::LINE_8, 0)?;
        
        // ä¸­å¿ƒå°åœ†æ¨¡æ¿ï¼ˆç”¨äºDTå³°å€¼æœç´¢ï¼‰
        let mut center = core::Mat::zeros(roi_side, roi_side, core::CV_8U)?.to_mat()?;
        imgproc::circle(&mut center, c, (0.8 * rin) as i32, core::Scalar::all(255.0), -1, imgproc::LINE_8, 0)?;
        
        Ok(Self {
            inner_mask_u8: inner,
            ring_mask_u8: ring,
            center_template: center,
        })
    }
    
    fn center_mask(&self, out: &mut core::Mat) -> Result<(), opencv::Error> {
        *out = self.center_template.try_clone()?;
        Ok(())
    }
}

/// ğŸš€ V3: æåæ ‡é‡‡æ ·è¡¨ï¼ˆé¢„è®¡ç®—è§’åº¦ï¼‰
struct PolarTable {
    n: usize,
    cos: Vec<f32>,
    sin: Vec<f32>,
}

impl PolarTable {
    fn new(n_dirs: usize) -> Self {
        let mut cos = Vec::with_capacity(n_dirs);
        let mut sin = Vec::with_capacity(n_dirs);
        
        for k in 0..n_dirs {
            let theta = (k as f32) * 2.0 * std::f32::consts::PI / (n_dirs as f32);
            cos.push(theta.cos());
            sin.push(theta.sin());
        }
        
        Self { n: n_dirs, cos, sin }
    }
}

/// ğŸš€ V3.2: é¢„è®¡ç®—ç»“æ„ï¼ˆå¤ç”¨æ©è†œä¸æ ¸ï¼‰
pub struct Precomputed {
    // å¤ç”¨çš„æ©è†œä¸æ ¸
    pub mask_edgeband: core::Mat,   // r0Â±Î”
    pub mask_outer: core::Mat,      // å™ªå£°å¤–ç¯
    pub kernel3: core::Mat,         // 3Ã—3å½¢æ€å­¦æ ¸
    pub polar: PolarTable,          // ä½ç½®ä¿¡åˆ†æ”¯ç”¨
    pub roi_side: i32,
    pub r0: f32,
    pub band_halfw: i32,
    pub outer_w: i32,
}

impl Precomputed {
    pub fn new(d_nom: f32) -> Result<Self, opencv::Error> {
        let roi_side = ((1.6 * d_nom) as i32).clamp(96, 160);
        let r0 = 0.5 * d_nom;
        let band_halfw = 4;
        let outer_w = 6;

        // â€”â€” ç”Ÿæˆå›ºå®šROIå°ºå¯¸çš„ä¸¤å¼ ç¯å½¢æ©è†œï¼ˆä¸­å¿ƒåœ¨ROIä¸­å¿ƒï¼‰â€”â€”
        let mut edgeband = core::Mat::zeros(roi_side, roi_side, core::CV_8U)?.to_mat()?;
        let mut outer = core::Mat::zeros(roi_side, roi_side, core::CV_8U)?.to_mat()?;
        let c = core::Point::new(roi_side / 2, roi_side / 2);

        // edge band: r0Â±Î”
        imgproc::circle(&mut edgeband, c, (r0 + band_halfw as f32) as i32, core::Scalar::all(255.0), -1, imgproc::LINE_8, 0)?;
        imgproc::circle(&mut edgeband, c, (r0 - band_halfw as f32) as i32, core::Scalar::all(0.0), -1, imgproc::LINE_8, 0)?;

        // outer noise ring: (r0+6) ~ (r0+6+outer_w)
        imgproc::circle(&mut outer, c, (r0 + 6.0 + outer_w as f32) as i32, core::Scalar::all(255.0), -1, imgproc::LINE_8, 0)?;
        imgproc::circle(&mut outer, c, (r0 + 6.0) as i32, core::Scalar::all(0.0), -1, imgproc::LINE_8, 0)?;

        let kernel3 = imgproc::get_structuring_element(imgproc::MORPH_ELLIPSE, core::Size::new(3, 3), core::Point::new(-1, -1))?;
        
        Ok(Self {
            mask_edgeband: edgeband,
            mask_outer: outer,
            kernel3,
            polar: PolarTable::new(48),
            roi_side,
            r0,
            band_halfw,
            outer_w,
        })
    }
}

/// è¿é€šåŸŸåœ†ç‚¹æ£€æµ‹å™¨
pub struct ConnectedComponentsDetector {
    // é˜ˆå€¼å‚æ•°
    triangle_threshold: f64,
    high_threshold: f64,
    low_threshold: f64,
    
    // é¢ç§¯è¿‡æ»¤å‚æ•°
    min_area: f64,
    max_area: f64,
    
    // å›¾åƒä¿¡æ¯
    image_size: core::Size,
    expected_diameter_range: (f32, f32), // (67, 90)
    
    // æ˜¯å¦å·²åˆå§‹åŒ–Triangleé˜ˆå€¼
    triangle_initialized: bool,
    
    // ğŸ†• æ–°å¢ä¼˜åŒ–å‚æ•°
    connectivity: i32,           // è¿é€šæ€§ï¼š4è¿é€š
    roi_split_threshold: f64,    // ROIåˆ†è£‚é˜ˆå€¼ (1.6 * max_expected_area)
    aspect_ratio_min: f64,       // é•¿å®½æ¯”æœ€å°å€¼ 0.6
    aspect_ratio_max: f64,       // é•¿å®½æ¯”æœ€å¤§å€¼ 1.7
    fill_ratio_min: f64,         // å¡«å……æ¯”æœ€å°å€¼ 0.45
    fill_ratio_max: f64,         // å¡«å……æ¯”æœ€å¤§å€¼ 0.95
    
    // ğŸ¨ V3: Debugå¯è§†åŒ–ç›¸å…³å­—æ®µ
    last_refine_tags: Option<Vec<RefineTag>>,
    last_original_centers: Option<core::Vector<core::Point2f>>,
}

impl ConnectedComponentsDetector {
    /// åˆ›å»ºæ£€æµ‹å™¨å®ä¾‹
    pub fn new() -> Self {
        // è®¡ç®—æœŸæœ›é¢ç§¯èŒƒå›´
        let min_expected_area = std::f64::consts::PI * (67.0_f64 / 2.0).powi(2); // â‰ˆ 3525
        let max_expected_area = std::f64::consts::PI * (90.0_f64 / 2.0).powi(2); // â‰ˆ 6362
        
        Self {
            triangle_threshold: 0.0,
            high_threshold: 0.0,
            low_threshold: 0.0,
            // ğŸ”§ ç¬¬ä¸€è½®å®½æ¾é¢ç§¯çª—å£ [1600, 14000]
            min_area: 1600.0,
            max_area: 14000.0,
            image_size: core::Size::new(2448, 2048),
            expected_diameter_range: (67.0, 90.0),
            triangle_initialized: false,
            // ğŸ†• æ–°å¢ä¼˜åŒ–å‚æ•°
            connectivity: 4,                                    // 4è¿é€šå‡å°‘é»è¿
            roi_split_threshold: 1.6 * max_expected_area,      // â‰ˆ 10179
            aspect_ratio_min: 0.6,                             // é•¿å®½æ¯”èŒƒå›´
            aspect_ratio_max: 1.7,
            fill_ratio_min: 0.45,                              // å¡«å……æ¯”èŒƒå›´ (åœ†â‰ˆÏ€/4â‰ˆ0.785)
            fill_ratio_max: 0.95,
            
            // ğŸ¨ V3: Debugå¯è§†åŒ–å­—æ®µåˆå§‹åŒ–
            last_refine_tags: None,
            last_original_centers: None,
        }
    }
    
    /// åˆå§‹åŒ–Triangleé˜ˆå€¼ (ä»…åœ¨é¦–æ¬¡è°ƒç”¨æ—¶æ‰§è¡Œ)
    fn initialize_triangle_threshold(&mut self, image: &core::Mat) -> Result<(), opencv::Error> {
        if self.triangle_initialized {
            return Ok(());
        }
        
        println!("ğŸ”§ åˆå§‹åŒ–Triangleé˜ˆå€¼...");
        let mut temp = core::Mat::default();
        
        // ä½¿ç”¨Triangleç®—æ³•è®¡ç®—åˆå§‹é˜ˆå€¼
        self.triangle_threshold = imgproc::threshold(
            image, 
            &mut temp, 
            0.0, 
            255.0, 
            imgproc::THRESH_BINARY | imgproc::THRESH_TRIANGLE
        )?;
        
        // ğŸ”§ è®¡ç®—é«˜ä½é˜ˆå€¼ - é«˜é˜ˆå€¼æ›´é«˜ï¼Œä½é˜ˆå€¼å·®è·æ›´å¤§
        self.high_threshold = self.triangle_threshold + 25.0;  // æ”¶ç´§äº®æ ¸
        self.low_threshold = (self.high_threshold - 60.0).max(10.0);  // æ›´å¤§å·®è·
        
        println!("   Triangleé˜ˆå€¼: {:.1}", self.triangle_threshold);
        println!("   é«˜é˜ˆå€¼: {:.1}", self.high_threshold);
        println!("   ä½é˜ˆå€¼: {:.1}", self.low_threshold);
        
        self.triangle_initialized = true;
        Ok(())
    }
    
    /// è¿é€šåŸŸåœ†ç‚¹æ£€æµ‹ä¸»å‡½æ•°
    pub fn detect_circles(&mut self, image: &core::Mat) -> Result<core::Vector<core::Point2f>, opencv::Error> {
        let detection_start = Instant::now();
        
        // åˆå§‹åŒ–é˜ˆå€¼ (ä»…é¦–æ¬¡)
        self.initialize_triangle_threshold(image)?;
        
        // ä¸»è·¯å¾„ï¼šé«˜é˜ˆå€¼æ£€æµ‹
        let mut centers = self.detect_with_threshold(image, self.high_threshold)?;
        println!("ğŸ” é«˜é˜ˆå€¼æ£€æµ‹åˆ° {} ä¸ªåœ†ç‚¹", centers.len());
        
        // å…œåº•è·¯å¾„ï¼šå¦‚æœæ£€æµ‹æ•°é‡ä¸è¶³ï¼Œä½¿ç”¨ä½é˜ˆå€¼è¡¥å……
        if centers.len() < 40 {
            println!("âš ï¸ æ£€æµ‹æ•°é‡ä¸è¶³ï¼Œå¯ç”¨ä½é˜ˆå€¼å…œåº•æ£€æµ‹...");
            let low_centers = self.detect_with_threshold(image, self.low_threshold)?;
            println!("ğŸ” ä½é˜ˆå€¼æ£€æµ‹åˆ° {} ä¸ªåœ†ç‚¹", low_centers.len());
            
            // åˆå¹¶å»é‡ (ç®€å•è·ç¦»å»é‡)
            centers = self.merge_and_deduplicate(centers, low_centers)?;
            println!("ğŸ”— åˆå¹¶å»é‡å: {} ä¸ªåœ†ç‚¹", centers.len());
        }
        
        // ğŸ†• V3: è¾¹ç•Œçº¦æŸè‡ªé€‚åº”åœ†å¿ƒç»†åŒ– (è§£å†³å‘é˜µåˆ—ä¸­å¿ƒåç§»é—®é¢˜ï¼Œå¯å›æ»šåˆ°èƒŒæ™¯å¹³å¦åŒ–ç‰ˆæœ¬)
        let (refine_tags, original_centers) = if centers.len() == 40 {
            println!("ğŸ”§ å¯åŠ¨è¾¹ç•Œçº¦æŸè‡ªé€‚åº”åœ†å¿ƒç»†åŒ–...");
            let refine_start = Instant::now();
            let original_centers = centers.clone(); // ğŸ¨ ä¿å­˜åŸå§‹åæ ‡
            let (refined_centers, tags) = self.refine_centers_adaptive_v3(image, centers)?;
            centers = refined_centers;
            let refine_time = refine_start.elapsed();
            println!("   âœ… è¾¹ç•Œçº¦æŸç»†åŒ–å®Œæˆï¼Œè€—æ—¶: {:.1} ms", refine_time.as_millis());
            (Some(tags), Some(original_centers))
        } else {
            (None, None)
        };
        
        // ğŸ¨ V3: å­˜å‚¨ç»†åŒ–ä¿¡æ¯ä¾›debugä½¿ç”¨
        self.last_refine_tags = refine_tags;
        self.last_original_centers = original_centers;
        
        let detection_time = detection_start.elapsed();
        println!("â±ï¸  è¿é€šåŸŸæ£€æµ‹æ€»è€—æ—¶: {:.1} ms", detection_time.as_millis());
        
        Ok(centers)
    }
    
    /// ä½¿ç”¨æŒ‡å®šé˜ˆå€¼è¿›è¡Œè¿é€šåŸŸæ£€æµ‹ - æ–°å¢èƒŒæ™¯å¹³å¦åŒ–é¢„å¤„ç†
    fn detect_with_threshold(&self, image: &core::Mat, threshold: f64) -> Result<core::Vector<core::Point2f>, opencv::Error> {
        println!("   ğŸ” é˜ˆå€¼æ£€æµ‹: {:.1}", threshold);
        
        // ğŸ†• èƒŒæ™¯å¹³å¦åŒ–é¢„å¤„ç† (æè½»é‡ï¼Œ<2ms)
        let d_nom = (self.expected_diameter_range.0 + self.expected_diameter_range.1) / 2.0; // â‰ˆ 78.5
        let sigma = d_nom * 0.8; // â‰ˆ 62.8
        
        // é«˜æ–¯æ¨¡ç³Šæå–èƒŒæ™¯ - ä½¿ç”¨blurç®€åŒ–å®ç°
        let mut bg = core::Mat::default();
        let kernel_size = ((sigma * 3.0) as i32 * 2 + 1).max(3); // 3Ïƒè§„åˆ™
        let ksize = core::Size::new(kernel_size, kernel_size);
        imgproc::blur(image, &mut bg, ksize, core::Point::new(-1, -1), core::BORDER_DEFAULT)?;
        
        // å‡å»èƒŒæ™¯å¾—åˆ°å¹³å¦åŒ–å›¾åƒ
        let mut flat = core::Mat::default();
        core::subtract(image, &bg, &mut flat, &core::Mat::default(), -1)?;
        
        // å¿«é€Ÿé™å¹…é˜²æ­¢è¿‡æ›åŒºæ³›æ»¥
        let mut flat_truncated = core::Mat::default();
        imgproc::threshold(&flat, &mut flat_truncated, 255.0, 255.0, imgproc::THRESH_TRUNC)?;
        let flat = flat_truncated; // é‡æ–°ç»‘å®š
        
        println!("     ğŸ”§ èƒŒæ™¯å¹³å¦åŒ–å®Œæˆ (sigma={:.1})", sigma);
        
        // äºŒå€¼åŒ–
        let mut binary = core::Mat::default();
        imgproc::threshold(&flat, &mut binary, threshold, 255.0, imgproc::THRESH_BINARY)?;
        
        // è¿é€šåŸŸåˆ†æ
        let mut labels = core::Mat::default();
        let mut stats = core::Mat::default();
        let mut centroids = core::Mat::default();
        
        let num_labels = imgproc::connected_components_with_stats(
            &binary, 
            &mut labels, 
            &mut stats, 
            &mut centroids, 
            self.connectivity, // ğŸ”§ 4è¿é€šå‡å°‘é»è¿
            core::CV_32S
        )?;
        
        // ğŸ” è®¡æ•°1: è¿é€šåŸŸæ€»æ•°ï¼ˆé˜ˆå€¼åï¼Œè¿‡æ»¤å‰ï¼‰
        let total_components = num_labels - 1; // å‡å»èƒŒæ™¯
        println!("   ğŸ“Š [è®¡æ•°1] è¿é€šåŸŸæ€»æ•°: {} (é˜ˆå€¼åï¼Œè¿‡æ»¤å‰)", total_components);
        
        // ğŸ” æ”¶é›†æ‰€æœ‰è¿é€šåŸŸé¢ç§¯ç”¨äºç»Ÿè®¡
        let mut all_areas = Vec::new();
        for i in 1..num_labels {
            let area = *stats.at_2d::<i32>(i, imgproc::CC_STAT_AREA)?;
            all_areas.push(area as f64);
        }
        all_areas.sort_by(|a, b| b.partial_cmp(a).unwrap()); // é™åºæ’åˆ—
        
        // ğŸ” æ‰“å°æœ€å¤§5ä¸ªè¿é€šåŸŸçš„é¢ç§¯
        println!("   ğŸ“Š æœ€å¤§5ä¸ªè¿é€šåŸŸé¢ç§¯: {:?}", 
                &all_areas[..std::cmp::min(5, all_areas.len())]);
        
        // é¢ç§¯è¿‡æ»¤å’Œå½¢çŠ¶ç­›é€‰
        let mut centers = core::Vector::<core::Point2f>::new();
        let mut area_filtered_count = 0;
        let mut shape_filtered_count = 0;
        let mut roi_split_candidates = Vec::new();
        
        for i in 1..num_labels { // è·³è¿‡èƒŒæ™¯(æ ‡ç­¾0)
            let area = *stats.at_2d::<i32>(i, imgproc::CC_STAT_AREA)?;
            let width = *stats.at_2d::<i32>(i, imgproc::CC_STAT_WIDTH)?;
            let height = *stats.at_2d::<i32>(i, imgproc::CC_STAT_HEIGHT)?;
            
            // ğŸ”§ ç¬¬ä¸€è½®ï¼šå®½æ¾é¢ç§¯è¿‡æ»¤
            if area as f64 >= self.min_area && area as f64 <= self.max_area {
                area_filtered_count += 1;
                
                // ğŸ”§ å½¢çŠ¶ç­›é€‰ï¼šé•¿å®½æ¯”å’Œå¡«å……æ¯”
                let aspect_ratio = width as f64 / height as f64;
                let fill_ratio = area as f64 / (width as f64 * height as f64);
                
                let shape_ok = aspect_ratio >= self.aspect_ratio_min && 
                              aspect_ratio <= self.aspect_ratio_max &&
                              fill_ratio >= self.fill_ratio_min && 
                              fill_ratio <= self.fill_ratio_max;
                
                if shape_ok {
                    shape_filtered_count += 1;
                    let cx = *centroids.at_2d::<f64>(i, 0)? as f32;
                    let cy = *centroids.at_2d::<f64>(i, 1)? as f32;
                    centers.push(core::Point2f::new(cx, cy));
                } else {
                    println!("   âš ï¸ å½¢çŠ¶ç­›é€‰ä¸¢å¼ƒ: é¢ç§¯={}, é•¿å®½æ¯”={:.2}, å¡«å……æ¯”={:.2}", 
                            area, aspect_ratio, fill_ratio);
                }
            } else if area as f64 > self.roi_split_threshold {
                // ğŸ”§ ROIåˆ†è£‚å€™é€‰ï¼šé¢ç§¯è¿‡å¤§çš„è¿é€šåŸŸ
                roi_split_candidates.push((i, area));
            }
        }
        
        println!("   ğŸ“Š å½¢çŠ¶ç­›é€‰: {} â†’ {} ä¸ª", area_filtered_count, shape_filtered_count);
        if !roi_split_candidates.is_empty() {
            println!("   ğŸ“Š ROIåˆ†è£‚å€™é€‰: {} ä¸ªå¤§è¿é€šåŸŸ (é¢ç§¯ > {:.0})", 
                    roi_split_candidates.len(), self.roi_split_threshold);
            
            // ğŸ”§ ROIåˆ†è£‚å¤„ç†ï¼šè·ç¦»å˜æ¢ + å±€éƒ¨æå¤§å€¼
            let split_centers = self.process_roi_split_candidates(
                image, &binary, &labels, &stats, &roi_split_candidates
            )?;
            
            if !split_centers.is_empty() {
                println!("   ğŸ¯ ROIåˆ†è£‚æˆåŠŸ: ä» {} ä¸ªå¤§è¿é€šåŸŸä¸­æå– {} ä¸ªåœ†å¿ƒ", 
                        roi_split_candidates.len(), split_centers.len());
                
                // å°†åˆ†è£‚å¾—åˆ°çš„åœ†å¿ƒæ·»åŠ åˆ°ç»“æœä¸­
                for center in split_centers {
                    centers.push(center);
                }
            }
        }
        
        // ğŸ” è®¡æ•°2: é¢ç§¯è¿‡æ»¤åçš„ä¸ªæ•°
        println!("   ğŸ“Š [è®¡æ•°2] é¢ç§¯è¿‡æ»¤å: {} ä¸ª ({:.0}-{:.0} pxÂ²)", 
                area_filtered_count, self.min_area, self.max_area);
        
        // ğŸ” è®¡æ•°3: å½¢çŠ¶ç­›é€‰åçš„æœ€ç»ˆä¸ªæ•°
        println!("   ğŸ“Š [è®¡æ•°3] å½¢çŠ¶ç­›é€‰å: {} ä¸ªåœ†ç‚¹", centers.len());
        
        // ğŸ” é—®é¢˜è¯Šæ–­åˆ†æ
        if total_components >= 35 && area_filtered_count < 20 {
            println!("   âš ï¸ è¯Šæ–­: è¿é€šåŸŸè¶³å¤Ÿä½†é¢ç§¯è¿‡æ»¤å¤§å¹…ä¸‹é™ â†’ äº®åŒºé»è¿ + æš—åŒºè¿‡å°");
            if !roi_split_candidates.is_empty() {
                println!("   ğŸ’¡ å»ºè®®: å¯ç”¨ROIåˆ†è£‚å¤„ç† {} ä¸ªå¤§è¿é€šåŸŸ", roi_split_candidates.len());
            } else {
                println!("   ğŸ’¡ å»ºè®®: é™ä½é˜ˆå€¼æˆ–è°ƒæ•´é¢ç§¯çª—å£");
            }
        } else if total_components < 30 {
            println!("   âš ï¸ è¯Šæ–­: è¿é€šåŸŸæ€»æ•°åå°‘ â†’ é˜ˆå€¼åé«˜å¯¼è‡´æš—ç‚¹æ²¡å‡ºè¿é€šåŸŸ");
            println!("   ğŸ’¡ å»ºè®®: é™ä½é˜ˆå€¼ ({:.1} â†’ {:.1}) æˆ–ä½¿ç”¨å±€éƒ¨Otsuå…œåº•", 
                    threshold, threshold * 0.8);
        } else if area_filtered_count >= 30 && shape_filtered_count < 25 {
            println!("   âš ï¸ è¯Šæ–­: é¢ç§¯è¿‡æ»¤æ­£å¸¸ä½†å½¢çŠ¶ç­›é€‰ä¸¢å¼ƒè¿‡å¤š â†’ é»è¿å¯¼è‡´å½¢çŠ¶å¼‚å¸¸");
            println!("   ğŸ’¡ å»ºè®®: æ”¾å®½å½¢çŠ¶é˜ˆå€¼æˆ–å¯ç”¨ROIåˆ†è£‚");
        } else if shape_filtered_count >= 30 {
            println!("   âœ… è¯Šæ–­: æ£€æµ‹æµç¨‹æ­£å¸¸ï¼Œ4è¿é€š+å½¢çŠ¶ç­›é€‰æ•ˆæœè‰¯å¥½");
        } else {
            println!("   âš ï¸ è¯Šæ–­: æ£€æµ‹ç»“æœåå°‘ï¼Œéœ€è¦ç»¼åˆè°ƒä¼˜");
        }
        
        Ok(centers)
    }
    
    /// åˆå¹¶ä¸¤ä¸ªæ£€æµ‹ç»“æœå¹¶å»é‡
    fn merge_and_deduplicate(
        &self, 
        centers1: core::Vector<core::Point2f>, 
        centers2: core::Vector<core::Point2f>
    ) -> Result<core::Vector<core::Point2f>, opencv::Error> {
        let mut merged = centers1.clone();
        let d_nom = (self.expected_diameter_range.0 + self.expected_diameter_range.1) / 2.0; // â‰ˆ 78.5
        let min_distance = 0.5 * d_nom; // â‰ˆ 39pxï¼Œ0.5*D_nomé¿å…åŒåœ†é‡å¤
        
        for i in 0..centers2.len() {
            let new_point = centers2.get(i)?;
            let mut is_duplicate = false;
            
            // æ£€æŸ¥æ˜¯å¦ä¸å·²æœ‰ç‚¹é‡å¤
            for j in 0..merged.len() {
                let existing_point = merged.get(j)?;
                let dx = new_point.x - existing_point.x;
                let dy = new_point.y - existing_point.y;
                let distance = (dx * dx + dy * dy).sqrt();
                
                if distance < min_distance {
                    is_duplicate = true;
                    break;
                }
            }
            
            if !is_duplicate {
                merged.push(new_point);
            }
        }
        
        Ok(merged)
    }
    
    /// ROIåˆ†è£‚å¤„ç†ï¼šè·ç¦»å˜æ¢ + å±€éƒ¨æå¤§å€¼å¿«åˆ†è£‚
    fn process_roi_split_candidates(
        &self,
        image: &core::Mat,
        binary: &core::Mat,
        labels: &core::Mat,
        stats: &core::Mat,
        candidates: &[(i32, i32)]
    ) -> Result<Vec<core::Point2f>, opencv::Error> {
        let mut split_centers = Vec::new();
        let d_nom = (self.expected_diameter_range.0 + self.expected_diameter_range.1) / 2.0; // â‰ˆ 78.5
        
        for &(label_id, area) in candidates {
            println!("   ğŸ” å¤„ç†å¤§è¿é€šåŸŸ #{}: é¢ç§¯={}", label_id, area);
            
            // è·å–è¯¥è¿é€šåŸŸçš„bbox
            let x = *stats.at_2d::<i32>(label_id, imgproc::CC_STAT_LEFT)?;
            let y = *stats.at_2d::<i32>(label_id, imgproc::CC_STAT_TOP)?;
            let w = *stats.at_2d::<i32>(label_id, imgproc::CC_STAT_WIDTH)?;
            let h = *stats.at_2d::<i32>(label_id, imgproc::CC_STAT_HEIGHT)?;
            
            let roi_rect = core::Rect::new(x, y, w, h);
            println!("     ğŸ“¦ ROIåŒºåŸŸ: {}Ã—{} at ({}, {})", w, h, x, y);
            
            // æå–ROIåŒºåŸŸçš„äºŒå€¼æ©è†œ
            let roi_binary = core::Mat::roi(binary, roi_rect)?;
            let roi_labels = core::Mat::roi(labels, roi_rect)?;
            
            // åˆ›å»ºè¯¥è¿é€šåŸŸçš„æ©è†œ (åªä¿ç•™å½“å‰label)
            let mut roi_mask = core::Mat::default();
            core::compare(&roi_labels, &core::Scalar::all(label_id as f64), &mut roi_mask, core::CMP_EQ)?;
            
            // è·ç¦»å˜æ¢å¿«åˆ†è£‚
            let roi_centers = self.distance_transform_split(&roi_mask, area as f64, d_nom)?;
            
            // å°†ROIåæ ‡è½¬æ¢ä¸ºå…¨å›¾åæ ‡
            for roi_center in roi_centers {
                let global_center = core::Point2f::new(
                    roi_center.x + x as f32,
                    roi_center.y + y as f32
                );
                split_centers.push(global_center);
            }
        }
        
        Ok(split_centers)
    }
    
    /// è·ç¦»å˜æ¢ + å±€éƒ¨æå¤§å€¼åˆ†è£‚
    fn distance_transform_split(
        &self,
        roi_mask: &core::Mat,
        area: f64,
        d_nom: f32
    ) -> Result<Vec<core::Point2f>, opencv::Error> {
        // ä¼°è®¡è¯¥ROIåº”åŒ…å«çš„åœ†ç‚¹æ•°é‡ - æé«˜ä¸Šé™
        let expected_area = std::f64::consts::PI * (d_nom as f64 / 2.0).powi(2); // â‰ˆ 4840
        let k_est_raw = (area / expected_area).round();
        let k_est = k_est_raw.max(2.0).min(25.0) as usize; // ğŸ”§ æé«˜ä¸Šé™åˆ°25ä¸ªï¼Œæœ€å°‘2ä¸ª
        
        println!("     ğŸ¯ é¢„ä¼°åœ†ç‚¹æ•°: {} (é¢ç§¯={:.0}, å•åœ†â‰ˆ{:.0})", k_est, area, expected_area);
        
        // âœ… ç›´æ¥å¯¹å‰æ™¯åšè·ç¦»å˜æ¢ (ä¸è¦bitwise_not!)
        // OpenCVçš„distanceTransformå¯¹éé›¶åƒç´ è®¡ç®—åˆ°æœ€è¿‘0åƒç´ çš„è·ç¦»
        let mut dist = core::Mat::default();
        imgproc::distance_transform(roi_mask, &mut dist, imgproc::DIST_L2, 3, core::CV_32F)?;
        
        // è·å–è·ç¦»å˜æ¢çš„æœ€å¤§å€¼
        let mut min_val = 0.0;
        let mut max_val = 0.0;
        core::min_max_loc(&dist, Some(&mut min_val), Some(&mut max_val), None, None, &core::Mat::default())?;
        
        println!("     ğŸ“ è·ç¦»å˜æ¢èŒƒå›´: {:.1} - {:.1}", min_val, max_val);
        
        if max_val < 5.0 {
            println!("     âš ï¸ è·ç¦»å˜æ¢å€¼è¿‡å°ï¼Œè·³è¿‡åˆ†è£‚");
            return Ok(Vec::new());
        }
        
        // ğŸ”§ å±è”½ROIè¾¹æ¡†é¿å…è§’ç‚¹æˆä¸ºä¼ªå³°
        let margin = (0.6 * d_nom) as i32;
        let rows = dist.rows();
        let cols = dist.cols();
        
        if margin < rows / 2 && margin < cols / 2 {
            let zero_scalar = core::Scalar::all(0.0);
            
            // ä½¿ç”¨rectangleå‡½æ•°å¡«å……è¾¹æ¡†åŒºåŸŸä¸º0
            // ä¸Šè¾¹æ¡†
            imgproc::rectangle(
                &mut dist,
                core::Rect::new(0, 0, cols, margin),
                zero_scalar,
                -1, // å¡«å……
                imgproc::LINE_8,
                0
            )?;
            
            // ä¸‹è¾¹æ¡†
            imgproc::rectangle(
                &mut dist,
                core::Rect::new(0, rows - margin, cols, margin),
                zero_scalar,
                -1,
                imgproc::LINE_8,
                0
            )?;
            
            // å·¦è¾¹æ¡†
            imgproc::rectangle(
                &mut dist,
                core::Rect::new(0, 0, margin, rows),
                zero_scalar,
                -1,
                imgproc::LINE_8,
                0
            )?;
            
            // å³è¾¹æ¡†
            imgproc::rectangle(
                &mut dist,
                core::Rect::new(cols - margin, 0, margin, rows),
                zero_scalar,
                -1,
                imgproc::LINE_8,
                0
            )?;
            
            println!("     ğŸ›¡ï¸ å·²å±è”½è¾¹æ¡† margin={} é¿å…è§’ç‚¹ä¼ªå³°", margin);
        }
        
        // ğŸ”§ å±€éƒ¨æå¤§å€¼æ£€æµ‹ï¼šä½¿ç”¨æ›´å°çš„æ ¸å‡å°‘è€—æ—¶
        let nms_radius = (0.4 * d_nom) as i32; // ğŸ”§ ä»0.6å‡å°‘åˆ°0.4ï¼Œâ‰ˆ 31px
        let kernel_size = (nms_radius * 2 + 1).max(3).min(63); // é™åˆ¶æœ€å¤§æ ¸å°ºå¯¸
        let kernel = imgproc::get_structuring_element(
            imgproc::MORPH_ELLIPSE,
            core::Size::new(kernel_size, kernel_size),
            core::Point::new(-1, -1)
        )?;
        
        println!("     ğŸ”§ NMSæ ¸å°ºå¯¸: {}Ã—{} (åŠå¾„={})", kernel_size, kernel_size, nms_radius);
        
        let mut dilated = core::Mat::default();
        imgproc::dilate(&dist, &mut dilated, &kernel, core::Point::new(-1, -1), 1, core::BORDER_CONSTANT, imgproc::morphology_default_border_value()?)?;
        
        // å±€éƒ¨æå¤§å€¼ = è†¨èƒ€åä¸åŸå›¾ç›¸ç­‰çš„ç‚¹
        let mut local_max = core::Mat::default();
        core::compare(&dist, &dilated, &mut local_max, core::CMP_EQ)?;
        
        // ğŸ”§ å¼ºåº¦é˜ˆå€¼ï¼šæ›´ä¿å®ˆçš„é˜ˆå€¼é¿å…å™ªå£°å³°
        let intensity_thresh = (0.3 * max_val).max(d_nom as f64 * 0.25); // ğŸ”§ é™ä½é˜ˆå€¼ç³»æ•°
        let mut strong_mask = core::Mat::default();
        core::compare(&dist, &core::Scalar::all(intensity_thresh), &mut strong_mask, core::CMP_GT)?;
        
        // ç»“åˆå±€éƒ¨æå¤§å€¼å’Œå¼ºåº¦é˜ˆå€¼
        let mut peaks = core::Mat::default();
        core::bitwise_and(&local_max, &strong_mask, &mut peaks, &core::Mat::default())?;
        
        // æ‰¾åˆ°æ‰€æœ‰å³°å€¼ç‚¹
        let mut peak_locations = core::Vector::<core::Point>::new();
        core::find_non_zero(&peaks, &mut peak_locations)?;
        
        println!("     ğŸ” æ‰¾åˆ° {} ä¸ªå€™é€‰å³°å€¼", peak_locations.len());
        
        if peak_locations.is_empty() {
            return Ok(Vec::new());
        }
        
        // æŒ‰è·ç¦»å˜æ¢å€¼æ’åºï¼Œå–å‰k_estä¸ª
        let mut peak_values = Vec::new();
        for i in 0..peak_locations.len() {
            let pt = peak_locations.get(i)?;
            let dist_val = *dist.at_2d::<f32>(pt.y, pt.x)?;
            peak_values.push((pt, dist_val));
        }
        
        // æŒ‰è·ç¦»å€¼é™åºæ’åº
        peak_values.sort_by(|a, b| b.1.partial_cmp(&a.1).unwrap());
        
        // å–å‰k_estä¸ªå³°å€¼
        let selected_peaks = peak_values.into_iter()
            .take(k_est)
            .collect::<Vec<_>>();
        
        println!("     âœ… é€‰æ‹©å‰ {} ä¸ªå³°å€¼ä½œä¸ºåœ†å¿ƒ", selected_peaks.len());
        
        // è½¬æ¢ä¸ºPoint2få¹¶æ·»åŠ è¯¦ç»†è°ƒè¯•
        let mut centers = Vec::new();
        for (i, (pt, dist_val)) in selected_peaks.iter().enumerate() {
            // æ£€æŸ¥æ˜¯å¦åœ¨è¾¹è§’ (è°ƒè¯•ç”¨)
            let near_edge = pt.x < margin || pt.y < margin || 
                           pt.x >= (cols - margin) || pt.y >= (rows - margin);
            let edge_flag = if near_edge { "âš ï¸è¾¹ç¼˜" } else { "âœ…å†…éƒ¨" };
            
            println!("       å³°å€¼{}: ({}, {}) å¼ºåº¦={:.1} {}", 
                    i+1, pt.x, pt.y, dist_val, edge_flag);
            centers.push(core::Point2f::new(pt.x as f32, pt.y as f32));
        }
        
        Ok(centers)
    }
    
    /// ğŸš€ V3.2: æ—©åœçŸ­è·¯ + å»‰ä»·æ¢¯åº¦è®¡ç®—ï¼ˆè§£å†³æ€§èƒ½ç“¶é¢ˆï¼‰
    /// ğŸ“Œ å›æ»šè¯´æ˜: åˆ é™¤æ­¤å‡½æ•°å’Œç›¸å…³è¾…åŠ©å‡½æ•°åŠä¸»å‡½æ•°è°ƒç”¨å³å¯å›åˆ°èƒŒæ™¯å¹³å¦åŒ–ç‰ˆæœ¬
    fn refine_centers_adaptive_v3(
        &self,
        image: &core::Mat,
        centers: core::Vector<core::Point2f>
    ) -> Result<(core::Vector<core::Point2f>, Vec<RefineTag>), opencv::Error> {
        let mut refined = core::Vector::<core::Point2f>::new();
        let mut tags = Vec::<RefineTag>::new(); // ğŸ¨ è®°å½•æ¯ä¸ªç‚¹çš„ç»†åŒ–æ¥æº
        
        let d_nom = (self.expected_diameter_range.0 + self.expected_diameter_range.1) / 2.0; // â‰ˆ78.5
        
        // ğŸš€ é¢„è®¡ç®—ç»“æ„ï¼ˆä¸€æ¬¡ç”Ÿæˆï¼Œ40æ¬¡å¤ç”¨ï¼‰
        let pc = Precomputed::new(d_nom as f32)?;
        
        // ğŸš€ å…¨å¸§ä¸€æ¬¡æ€§Scharr |âˆ‡I| ä¸1/2å°ºåº¦é‡‘å­—å¡”ï¼ˆä¾›ä½äº®ç‚¹ç”¨ï¼‰
        let (grad_mag, grad_mag_pyr) = Self::precompute_gradients(image)?; // åªåšä¸€æ¬¡
        
        let mut n_high = 0;
        let mut n_low = 0;
        let mut n_fallback = 0;
        
        println!("   ğŸ“ V3.2æ—©åœçŸ­è·¯: ROI={}Ã—{}, r0={:.1}, é¢„è®¡ç®—å®Œæˆ",
                pc.roi_side, pc.roi_side, pc.r0);
        
        for i in 0..centers.len() {
            let c0 = centers.get(i)?;
            let rr = Self::roi_at(c0, pc.roi_side, image.cols(), image.rows());
            let roi_gray = core::Mat::roi(image, rr)?.try_clone()?;
            
            // â€”â€” ğŸš€ äº®åº¦å¿«é—¨ï¼šé€šè¿‡å³ç›´æ¥DT-onlyï¼›ä¸ç®—æ¢¯åº¦ â€”â€”
            if Self::brightness_gate_fast(&roi_gray, pc.r0)? {
                let c = Self::refine_dt_fast_reuse(&roi_gray, rr, &pc.kernel3, pc.r0)?;
                Self::push_with_guard(c0, c, pc.r0 * 0.7, &mut refined, &mut tags, &mut n_fallback, RefineTag::Hi);
                n_high += 1;
                continue; // **çŸ­è·¯ï¼šä¸ç®—ä»»ä½•æ¢¯åº¦ç½®ä¿¡**
            }
            
            // â€”â€” ğŸš€ åªåˆ°è¿™é‡Œçš„ç‚¹æ‰å»ç®—æ¢¯åº¦ç½®ä¿¡ï¼ˆåœ¨1/2å°ºåº¦ä¸Šï¼‰â€”â€”
            let rr_half = Self::rect_half(rr);
            let roi_gm_half = core::Mat::roi(&grad_mag_pyr, rr_half)?.try_clone()?;
            let ec = Self::edge_conf_hist_p90(&roi_gm_half, &pc.mask_edgeband, &pc.mask_outer)?;
            
            if ec >= 2.0 {
                let c = Self::refine_dt_fast_reuse(&roi_gray, rr, &pc.kernel3, pc.r0)?;
                Self::push_with_guard(c0, c, pc.r0 * 0.7, &mut refined, &mut tags, &mut n_fallback, RefineTag::Hi);
                n_high += 1;
            } else {
                // ğŸš€ ä½ç½®ä¿¡ï¼šå¾„å‘é‡‡æ ·Prattï¼ˆä¿æŒç°æœ‰å®ç°ï¼Œä½†ç”¨pc.polarï¼Œæ­¥é•¿0.8ï¼‰
                let (ok, c) = Self::refine_dark_radial_fit_fast(&roi_gray, rr, &pc.polar, 0.85 * pc.r0, 1.15 * pc.r0, pc.r0, 0.8)?;
                if ok {
                    Self::push_with_guard(c0, c, pc.r0 * 0.7, &mut refined, &mut tags, &mut n_fallback, RefineTag::Lo);
                } else {
                    refined.push(c0);
                    tags.push(RefineTag::Fallback);
                    n_fallback += 1;
                }
                n_low += 1;
            }
        }
        
        println!("   ğŸ“Š V3.2æ—©åœç»†åŒ–: é«˜ç½®ä¿¡(DT-only)={} ä¸ª, ä½ç½®ä¿¡(å¾„å‘é‡‡æ ·)={} ä¸ª, å›é€€={} ä¸ª",
                n_high, n_low, n_fallback);
        Ok((refined, tags))
    }
    
    /// ğŸ†• V2: è½»é‡çº§è‡ªé€‚åº”åœ†å¿ƒç»†åŒ– - åŸºäºSNRå’Œè¿‡æ›æ¯”ä¾‹çš„åˆ†æ”¯ç­–ç•¥ (å·²å¼ƒç”¨ï¼Œä¿ç•™ä¾›å‚è€ƒ)
    /// ğŸ“Œ å›æ»šè¯´æ˜: åˆ é™¤æ­¤å‡½æ•°å’Œä¸»å‡½æ•°ä¸­çš„è°ƒç”¨å³å¯å›åˆ°èƒŒæ™¯å¹³å¦åŒ–ç‰ˆæœ¬
    #[allow(dead_code)]
    fn refine_centers_adaptive_v2(
        &self,
        image: &core::Mat,
        centers: core::Vector<core::Point2f>
    ) -> Result<core::Vector<core::Point2f>, opencv::Error> {
        let mut refined_centers = core::Vector::<core::Point2f>::new();
        let d_nom = (self.expected_diameter_range.0 + self.expected_diameter_range.1) / 2.0; // â‰ˆ 78.5
        
        // ğŸ”§ V2ä¼˜åŒ–: ROIå°ºå¯¸ = 1.6*D_nomï¼Œç¡®ä¿å®Œæ•´åŒ…å«åœ†ç‚¹
        let roi_size = ((1.6 * d_nom) as i32).clamp(96, 160); // â‰ˆ 125px
        
        // å®šä¹‰ä¸‰ä¸ªåŠå¾„ç”¨äºSNRè®¡ç®—
        let r_in = 0.45 * d_nom;   // å†…ç›˜åŠå¾„ â‰ˆ 35px
        let r_mid = 0.65 * d_nom;  // ç¯å½¢å†…å¾„ â‰ˆ 51px  
        let r_out = 0.90 * d_nom;  // ç¯å½¢å¤–å¾„ â‰ˆ 71px
        
        let mut bright_count = 0;  // SNR>=8 æˆ– è¿‡æ›>2%
        let mut dark_count = 0;    // SNR<=4
        let mut mid_count = 0;     // 4<SNR<8
        let mut fallback_count = 0; // ç»†åŒ–å¤±è´¥å›é€€
        
        println!("   ğŸ“ ROIå°ºå¯¸: {}Ã—{}, åŠå¾„: r_in={:.1}, r_mid={:.1}, r_out={:.1}", 
                roi_size, roi_size, r_in, r_mid, r_out);
        
        for i in 0..centers.len() {
            let center = centers.get(i)?;
            let x0 = ((center.x as i32) - roi_size / 2).clamp(0, image.cols() - roi_size);
            let y0 = ((center.y as i32) - roi_size / 2).clamp(0, image.rows() - roi_size);
            
            let roi_rect = core::Rect::new(x0, y0, roi_size, roi_size);
            let roi = core::Mat::roi(image, roi_rect)?.try_clone()?;
            
            // ğŸ” è®¡ç®—å±€éƒ¨SNRå’Œè¿‡æ›æ¯”ä¾‹
            let (snr, sat_ratio) = self.calculate_local_snr_and_saturation(&roi, r_in, r_mid, r_out)?;
            
            // ğŸ¯ è‡ªé€‚åº”åˆ†æ”¯é€‰æ‹© (ä¸ä½¿ç”¨å›ºå®š120é˜ˆå€¼)
            let refined_center = if sat_ratio > 0.02 || snr >= 8.0 {
                // æ˜äº®/è¿‡æ›å‹: ä½¿ç”¨è·ç¦»å˜æ¢å³°å€¼ç»†åŒ–
                bright_count += 1;
                self.refine_bright_adaptive_dt(&roi, roi_rect, center, r_in, r_mid, r_out)?
            } else if snr <= 4.0 {
                // æš—/ä½å¯¹æ¯”å‹: ä½¿ç”¨è¾¹ç•Œæ‹Ÿåˆç»†åŒ–
                dark_count += 1;
                self.refine_dark_adaptive_edge(&roi, roi_rect, center, r_mid, r_out)?
            } else {
                // ä¸­é—´åœ°å¸¦: ä½¿ç”¨è·ç¦»å˜æ¢ (æ›´ç¨³å®š)
                mid_count += 1;
                self.refine_bright_adaptive_dt(&roi, roi_rect, center, r_in, r_mid, r_out)?
            };
            
            // ğŸ›¡ï¸ ä½ç§»çº¦æŸ: |Î”| > 0.35*D åˆ™å›é€€åˆ°åŸåæ ‡
            let displacement = ((refined_center.x - center.x).powi(2) + (refined_center.y - center.y).powi(2)).sqrt();
            let max_displacement = 0.35 * d_nom;
            
            if displacement <= max_displacement {
                refined_centers.push(refined_center);
            } else {
                refined_centers.push(center); // å›é€€åˆ°åŸåæ ‡
                fallback_count += 1;
            }
        }
        
        println!("   ğŸ“Š ç»†åŒ–ç»Ÿè®¡: æ˜äº®å‹{}ä¸ª, æš—éƒ¨å‹{}ä¸ª, ä¸­é—´å‹{}ä¸ª, å›é€€{}ä¸ª", 
                bright_count, dark_count, mid_count, fallback_count);
        
        Ok(refined_centers)
    }
    
    /// ğŸ” è®¡ç®—å±€éƒ¨SNRå’Œè¿‡æ›æ¯”ä¾‹
    fn calculate_local_snr_and_saturation(
        &self,
        roi: &core::Mat,
        r_in: f32,
        r_mid: f32, 
        r_out: f32
    ) -> Result<(f64, f64), opencv::Error> {
        let roi_center = core::Point2f::new(roi.cols() as f32 * 0.5, roi.rows() as f32 * 0.5);
        
        // åˆ›å»ºå†…ç›˜æ©è†œ
        let mut in_mask = core::Mat::zeros(roi.rows(), roi.cols(), core::CV_8U)?.to_mat()?;
        imgproc::circle(&mut in_mask, 
            core::Point::new(roi_center.x as i32, roi_center.y as i32),
            r_in as i32, 
            core::Scalar::all(255.0), 
            -1, imgproc::LINE_8, 0)?;
        
        // åˆ›å»ºç¯å½¢æ©è†œ (r_mid ~ r_out)
        let mut ring_mask = core::Mat::zeros(roi.rows(), roi.cols(), core::CV_8U)?.to_mat()?;
        imgproc::circle(&mut ring_mask,
            core::Point::new(roi_center.x as i32, roi_center.y as i32),
            r_out as i32,
            core::Scalar::all(255.0),
            -1, imgproc::LINE_8, 0)?;
        imgproc::circle(&mut ring_mask,
            core::Point::new(roi_center.x as i32, roi_center.y as i32),
            r_mid as i32,
            core::Scalar::all(0.0),
            -1, imgproc::LINE_8, 0)?;
        
        // è®¡ç®—å†…ç›˜å’Œç¯å½¢åŒºåŸŸçš„ç»Ÿè®¡é‡
        let mu_in = core::mean(roi, &in_mask)?;
        let mu_ring = core::mean(roi, &ring_mask)?;
        
        let mut std_dev = core::Scalar::default();
        let mut mean_val = core::Scalar::default();
        core::mean_std_dev(roi, &mut mean_val, &mut std_dev, &ring_mask)?;
        let sigma_ring = std_dev[0];
        
        // è®¡ç®—SNR
        let snr = (mu_in[0] - mu_ring[0]) / sigma_ring.max(1.0);
        
        // è®¡ç®—è¿‡æ›æ¯”ä¾‹ (>=250çš„åƒç´ åœ¨å†…ç›˜ä¸­çš„æ¯”ä¾‹)
        let mut sat_mask = core::Mat::default();
        imgproc::threshold(roi, &mut sat_mask, 250.0, 255.0, imgproc::THRESH_BINARY)?;
        let mut sat_in_mask = core::Mat::default();
        core::bitwise_and(&sat_mask, &in_mask, &mut sat_in_mask, &core::Mat::default())?;
        
        let sat_pixels = core::count_non_zero(&sat_in_mask)?;
        let total_in_pixels = core::count_non_zero(&in_mask)?.max(1);
        let sat_ratio = sat_pixels as f64 / total_in_pixels as f64;
        
        Ok((snr, sat_ratio))
    }
    
    /// ğŸ”† æ˜äº®å‹åœ†ç‚¹ç»†åŒ–: å±€éƒ¨è‡ªé€‚åº”é˜ˆå€¼ + è·ç¦»å˜æ¢å³°å€¼
    fn refine_bright_adaptive_dt(
        &self,
        roi: &core::Mat,
        roi_rect: core::Rect,
        original_center: core::Point2f,
        r_in: f32,
        r_mid: f32,
        r_out: f32
    ) -> Result<core::Point2f, opencv::Error> {
        let roi_center = core::Point2f::new(roi.cols() as f32 * 0.5, roi.rows() as f32 * 0.5);
        
        // è®¡ç®—å±€éƒ¨è‡ªé€‚åº”é˜ˆå€¼ (ä¸ä½¿ç”¨å…¨å±€é˜ˆå€¼)
        let mu_in = {
            let mut in_mask = core::Mat::zeros(roi.rows(), roi.cols(), core::CV_8U)?.to_mat()?;
            imgproc::circle(&mut in_mask, 
                core::Point::new(roi_center.x as i32, roi_center.y as i32),
                r_in as i32, core::Scalar::all(255.0), -1, imgproc::LINE_8, 0)?;
            core::mean(roi, &in_mask)?[0]
        };
        
        let mu_ring = {
            let mut ring_mask = core::Mat::zeros(roi.rows(), roi.cols(), core::CV_8U)?.to_mat()?;
            imgproc::circle(&mut ring_mask,
                core::Point::new(roi_center.x as i32, roi_center.y as i32),
                r_out as i32, core::Scalar::all(255.0), -1, imgproc::LINE_8, 0)?;
            imgproc::circle(&mut ring_mask,
                core::Point::new(roi_center.x as i32, roi_center.y as i32),
                r_mid as i32, core::Scalar::all(0.0), -1, imgproc::LINE_8, 0)?;
            core::mean(roi, &ring_mask)?[0]
        };
        
        let t_local = mu_ring + 0.5 * (mu_in - mu_ring);
        
        // äºŒå€¼åŒ– + è½»å¾®è…èš€
        let mut binary = core::Mat::default();
        imgproc::threshold(roi, &mut binary, t_local, 255.0, imgproc::THRESH_BINARY)?;
        
        let kernel = imgproc::get_structuring_element(imgproc::MORPH_ELLIPSE, core::Size::new(3, 3), core::Point::new(-1, -1))?;
        let mut eroded = core::Mat::default();
        imgproc::erode(&binary, &mut eroded, &kernel, core::Point::new(-1, -1), 1, core::BORDER_CONSTANT, imgproc::morphology_default_border_value()?)?;
        let binary = eroded; // é‡æ–°ç»‘å®š
        
        // è·ç¦»å˜æ¢
        let mut dist = core::Mat::default();
        imgproc::distance_transform(&binary, &mut dist, imgproc::DIST_L2, 3, core::CV_32F)?;
        
        // åœ¨å³°å€¼æœç´¢æ©è†œå†…æ‰¾æœ€å¤§å€¼ (åŠå¾„ â‰ˆ 0.8*r_in)
        let mut peak_mask = core::Mat::zeros(roi.rows(), roi.cols(), core::CV_8U)?.to_mat()?;
        let search_radius = (0.8 * r_in) as i32;
        imgproc::circle(&mut peak_mask,
            core::Point::new(roi_center.x as i32, roi_center.y as i32),
            search_radius, core::Scalar::all(255.0), -1, imgproc::LINE_8, 0)?;
        
        let mut min_val = 0.0;
        let mut max_val = 0.0;
        let mut min_loc = core::Point::default();
        let mut max_loc = core::Point::default();
        core::min_max_loc(&dist, Some(&mut min_val), Some(&mut max_val), Some(&mut min_loc), Some(&mut max_loc), &peak_mask)?;
        
        if max_val > 3.0 {
            // äºšåƒç´ å³°å€¼ç»†åŒ– (ç®€å•çš„0.5åƒç´ åç§»)
            let refined_x = max_loc.x as f32 + 0.5;
            let refined_y = max_loc.y as f32 + 0.5;
            
            Ok(core::Point2f::new(
                roi_rect.x as f32 + refined_x,
                roi_rect.y as f32 + refined_y
            ))
        } else {
            Ok(original_center)
        }
    }
    
    /// ğŸŒ‘ æš—éƒ¨å‹åœ†ç‚¹ç»†åŒ–: å½’ä¸€åŒ– + ç¯åŸŸçº¦æŸCanny + åœ†æ‹Ÿåˆ
    fn refine_dark_adaptive_edge(
        &self,
        roi: &core::Mat,
        roi_rect: core::Rect,
        original_center: core::Point2f,
        r_mid: f32,
        r_out: f32
    ) -> Result<core::Point2f, opencv::Error> {
        let roi_center = core::Point2f::new(roi.cols() as f32 * 0.5, roi.rows() as f32 * 0.5);
        
        // çº¿æ€§å½’ä¸€åŒ–åˆ°[0,255]
        let mut normalized = core::Mat::default();
        core::normalize(roi, &mut normalized, 0.0, 255.0, core::NORM_MINMAX, core::CV_8U, &core::Mat::default())?;
        
        // ğŸ”§ æ­£ç¡®ä½¿ç”¨gaussian_blur: ä½¿ç”¨Size(5,5)æ›¿ä»£Size(0,0)
        let mut blurred = core::Mat::default();
        imgproc::gaussian_blur(&normalized, &mut blurred, core::Size::new(5, 5), 1.2, 1.2, core::BORDER_DEFAULT, core::AlgorithmHint::ALGO_HINT_DEFAULT)?;
        
        // Cannyè¾¹ç¼˜æ£€æµ‹ (å›ºå®šå°é˜ˆå€¼)
        let mut edges = core::Mat::default();
        imgproc::canny(&blurred, &mut edges, 12.0, 36.0, 3, false)?;
        
        // ç¯åŸŸçº¦æŸ: åªåœ¨r_mid~r_outç¯å½¢åŒºåŸŸå†…ä¿ç•™è¾¹ç¼˜
        let mut ring_mask = core::Mat::zeros(roi.rows(), roi.cols(), core::CV_8U)?.to_mat()?;
        imgproc::circle(&mut ring_mask,
            core::Point::new(roi_center.x as i32, roi_center.y as i32),
            r_out as i32, core::Scalar::all(255.0), -1, imgproc::LINE_8, 0)?;
        imgproc::circle(&mut ring_mask,
            core::Point::new(roi_center.x as i32, roi_center.y as i32),
            r_mid as i32, core::Scalar::all(0.0), -1, imgproc::LINE_8, 0)?;
        
        let mut masked_edges = core::Mat::default();
        core::bitwise_and(&edges, &ring_mask, &mut masked_edges, &core::Mat::default())?;
        let edges = masked_edges; // é‡æ–°ç»‘å®š
        
        // æŸ¥æ‰¾è½®å»“å¹¶æ‹Ÿåˆåœ†
        let mut contours = core::Vector::<core::Vector<core::Point>>::new();
        imgproc::find_contours(&edges, &mut contours, imgproc::RETR_LIST, imgproc::CHAIN_APPROX_NONE, core::Point::default())?;
        
        if contours.len() == 0 {
            return Ok(original_center);
        }
        
        // æ‰¾åˆ°æœ€é•¿è½®å»“
        let mut max_length = 0;
        let mut best_contour_idx = 0;
        for i in 0..contours.len() {
            let contour = contours.get(i)?;
            if contour.len() > max_length {
                max_length = contour.len();
                best_contour_idx = i;
            }
        }
        
        if max_length < 20 {
            return Ok(original_center);
        }
        
        // æœ€å°å¤–æ¥åœ†æ‹Ÿåˆ
        let best_contour = contours.get(best_contour_idx)?;
        let mut center = core::Point2f::default();
        let mut radius = 0.0;
        imgproc::min_enclosing_circle(&best_contour, &mut center, &mut radius)?;
        
        // è½¬æ¢ä¸ºå…¨å›¾åæ ‡
        Ok(core::Point2f::new(
            roi_rect.x as f32 + center.x,
            roi_rect.y as f32 + center.y
        ))
    }
    
    /// ğŸš€ V3.1: ä¿®æ­£è¾¹ç¼˜ç½®ä¿¡åº¦ - çª„è¾¹å¸¦é«˜åˆ†ä½ / å¤–ç¯å™ªå£°MAD (å·²å¼ƒç”¨)
    #[allow(dead_code)]
    fn edge_confidence_v2(
        roi: &core::Mat,
        r0: f32,                // é¢„æœŸåŠå¾„ ~ D_nom/2
        band_halfw: i32,        // çª„è¾¹å¸¦åŠå®½
        outer_w: i32,           // å¤–ç¯å®½
    ) -> Result<f64, opencv::Error> {
        // 1) Scharræ¢¯åº¦å¹…å€¼
        let mut gx = core::Mat::default();
        let mut gy = core::Mat::default();
        imgproc::scharr(roi, &mut gx, core::CV_32F, 1, 0, 1.0, 0.0, core::BORDER_DEFAULT)?;
        imgproc::scharr(roi, &mut gy, core::CV_32F, 0, 1, 1.0, 0.0, core::BORDER_DEFAULT)?;
        
        let mut mag = core::Mat::default();
        core::magnitude(&gx, &gy, &mut mag)?;
        
        let cx = roi.cols() as f32 * 0.5;
        let cy = roi.rows() as f32 * 0.5;
        
        // 2) é‡‡æ ·å‡½æ•°ï¼šæŠŠmaskåœ†ç¯å†…åƒç´ çš„magæ‹‰æˆVec<f32>
        let mut edge_band = Vec::<f32>::new();
        let mut noise_band = Vec::<f32>::new();
        let (rb0, rb1) = (r0 - band_halfw as f32, r0 + band_halfw as f32);
        let (rn0, rn1) = (r0 + 6.0, r0 + 6.0 + outer_w as f32); // å¤–ç¯åç§»6px
        
        for y in 0..roi.rows() {
            for x in 0..roi.cols() {
                let dx = x as f32 - cx;
                let dy = y as f32 - cy;
                let r = (dx * dx + dy * dy).sqrt();
                let v = *mag.at_2d::<f32>(y, x)?;
                if r >= rb0 && r <= rb1 {
                    edge_band.push(v);
                } else if r >= rn0 && r <= rn1 {
                    noise_band.push(v);
                }
            }
        }
        
        if edge_band.is_empty() || noise_band.is_empty() {
            return Ok(0.0);
        }
        
        // 3) ä¿¡å·ï¼šP90ï¼ˆæˆ–Top-15%å‡å€¼ï¼‰
        edge_band.sort_by(|a, b| a.partial_cmp(b).unwrap());
        let p90_idx = (edge_band.len() as f32 * 0.9) as usize;
        let p90 = edge_band[p90_idx.min(edge_band.len() - 1)];
        
        // 4) å™ªå£°ï¼šMADâ†’Ïƒ
        let (_, mad) = Self::median_and_mad(&noise_band);
        let sigma = (mad * 1.4826).max(1e-3);
        
        Ok((p90 as f64) / (sigma as f64))
    }
    
    /// ğŸš€ V3.1: äº®åº¦å¿«é—¨ - é«˜å¯¹æ¯”/è¿‡æ›ç›´æ¥èµ°é«˜ç½®ä¿¡
    fn quick_brightness_gate(
        roi: &core::Mat,
        r_in: f32,
        r_ring0: f32,
        r_ring1: f32,
    ) -> Result<bool, opencv::Error> {
        let (mu_in, mu_ring, sigma_ring) = Self::mean_and_sigma_in_ring(roi, r_in, r_ring0, r_ring1)?;
        let snr_i = (mu_in - mu_ring) / sigma_ring.max(1.0);
        
        // å†…ç›˜è¿‡æ›æ¯”ä¾‹ï¼ˆ>=250ï¼‰
        let sat = Self::saturation_ratio_in_disk(roi, r_in)?;
        
        Ok(sat > 0.02 || snr_i >= 6.0)
    }
    
    /// ğŸš€ V3.1: è®¡ç®—ç¯åŸŸå†…çš„å‡å€¼å’Œæ ‡å‡†å·®
    fn mean_and_sigma_in_ring(
        roi: &core::Mat,
        r_in: f32,
        r_ring0: f32,
        r_ring1: f32,
    ) -> Result<(f64, f64, f64), opencv::Error> {
        let cx = roi.cols() as f32 * 0.5;
        let cy = roi.rows() as f32 * 0.5;
        
        let mut in_vals = Vec::<f32>::new();
        let mut ring_vals = Vec::<f32>::new();
        
        for y in 0..roi.rows() {
            for x in 0..roi.cols() {
                let dx = x as f32 - cx;
                let dy = y as f32 - cy;
                let r = (dx * dx + dy * dy).sqrt();
                let v = *roi.at_2d::<u8>(y, x)? as f32;
                
                if r <= r_in {
                    in_vals.push(v);
                } else if r >= r_ring0 && r <= r_ring1 {
                    ring_vals.push(v);
                }
            }
        }
        
        let mu_in = if in_vals.is_empty() { 0.0 } else { 
            in_vals.iter().sum::<f32>() / in_vals.len() as f32 
        } as f64;
        
        let mu_ring = if ring_vals.is_empty() { 0.0 } else { 
            ring_vals.iter().sum::<f32>() / ring_vals.len() as f32 
        } as f64;
        
        let sigma_ring = if ring_vals.len() < 2 { 1.0 } else {
            let mean = mu_ring as f32;
            let variance = ring_vals.iter()
                .map(|v| (v - mean).powi(2))
                .sum::<f32>() / (ring_vals.len() - 1) as f32;
            variance.sqrt() as f64
        };
        
        Ok((mu_in, mu_ring, sigma_ring))
    }
    
    /// ğŸš€ V3.1: è®¡ç®—åœ†ç›˜å†…è¿‡æ›æ¯”ä¾‹
    fn saturation_ratio_in_disk(roi: &core::Mat, r_in: f32) -> Result<f64, opencv::Error> {
        let cx = roi.cols() as f32 * 0.5;
        let cy = roi.rows() as f32 * 0.5;
        
        let mut total_pixels = 0;
        let mut sat_pixels = 0;
        
        for y in 0..roi.rows() {
            for x in 0..roi.cols() {
                let dx = x as f32 - cx;
                let dy = y as f32 - cy;
                let r = (dx * dx + dy * dy).sqrt();
                
                if r <= r_in {
                    total_pixels += 1;
                    let v = *roi.at_2d::<u8>(y, x)?;
                    if v >= 250 {
                        sat_pixels += 1;
                    }
                }
            }
        }
        
        if total_pixels == 0 {
            Ok(0.0)
        } else {
            Ok(sat_pixels as f64 / total_pixels as f64)
        }
    }
    
    /// ğŸš€ V3.2: å…¨å¸§é¢„è®¡ç®—æ¢¯åº¦
    fn precompute_gradients(gray: &core::Mat) -> Result<(core::Mat, core::Mat), opencv::Error> {
        let mut gx = core::Mat::default();
        let mut gy = core::Mat::default();
        imgproc::scharr(gray, &mut gx, core::CV_32F, 1, 0, 1.0, 0.0, core::BORDER_DEFAULT)?;
        imgproc::scharr(gray, &mut gy, core::CV_32F, 0, 1, 1.0, 0.0, core::BORDER_DEFAULT)?;
        
        let mut mag = core::Mat::default();
        core::magnitude(&gx, &gy, &mut mag)?;
        
        // 1/2å°ºåº¦ï¼ˆpyrDownï¼‰ï¼Œä¾›ç»Ÿè®¡ä½¿ç”¨
        let mut mag_half = core::Mat::default();
        imgproc::pyr_down(&mag, &mut mag_half, core::Size::default(), core::BORDER_DEFAULT)?;
        
        Ok((mag, mag_half))
    }
    
    /// ğŸš€ V3.2: äº®åº¦å¿«é—¨ï¼ˆè½»é‡ã€æ— æ¢¯åº¦ï¼‰
    fn brightness_gate_fast(roi: &core::Mat, r0: f32) -> Result<bool, opencv::Error> {
        let cx = roi.cols() as f32 * 0.5;
        let cy = roi.rows() as f32 * 0.5;
        
        // å†…ç›˜
        let mut m_in = core::Mat::zeros(roi.rows(), roi.cols(), core::CV_8U)?.to_mat()?;
        imgproc::circle(&mut m_in, core::Point::new(cx as i32, cy as i32), (0.8 * r0) as i32, core::Scalar::all(255.0), -1, imgproc::LINE_8, 0)?;
        
        // ç¯åŸŸï¼šr0..1.3r0
        let mut m_ring = core::Mat::zeros(roi.rows(), roi.cols(), core::CV_8U)?.to_mat()?;
        imgproc::circle(&mut m_ring, core::Point::new(cx as i32, cy as i32), (1.3 * r0) as i32, core::Scalar::all(255.0), -1, imgproc::LINE_8, 0)?;
        imgproc::circle(&mut m_ring, core::Point::new(cx as i32, cy as i32), (1.0 * r0) as i32, core::Scalar::all(0.0), -1, imgproc::LINE_8, 0)?;
        
        let mu_in = core::mean(roi, &m_in)?[0];
        let mu_ring = core::mean(roi, &m_ring)?[0];
        
        let mut mean_v = core::Scalar::default();
        let mut std_v = core::Scalar::default();
        core::mean_std_dev(roi, &mut mean_v, &mut std_v, &m_ring)?;
        let sigma_ring = std_v[0].max(1.0);
        
        // è¿‡æ›æ¯”ä¾‹ï¼ˆ>=250ï¼‰
        let mut sat = core::Mat::default();
        imgproc::threshold(roi, &mut sat, 250.0, 255.0, imgproc::THRESH_BINARY)?;
        let mut sat_in = core::Mat::default();
        core::bitwise_and(&sat, &m_in, &mut sat_in, &core::Mat::default())?;
        let sat_ratio = (core::count_non_zero(&sat_in)? as f64) / (core::count_non_zero(&m_in)? as f64).max(1.0);
        
        let snr = (mu_in - mu_ring) / sigma_ring;
        Ok(sat_ratio > 0.02 || snr >= 6.0)
    }
    
    /// ğŸš€ V3.2: è¿‘ä¼¼P90ï¼šç”¨32binç›´æ–¹å›¾+æ©è†œï¼ˆç¯å¸¦/å¤–ç¯åˆ†åˆ«ç»Ÿè®¡ï¼‰
    fn edge_conf_hist_p90(
        roi_grad_half: &core::Mat,
        mask_edgeband_full: &core::Mat,
        mask_outer_full: &core::Mat,
    ) -> Result<f64, opencv::Error> {
        // æ³¨æ„ï¼šROIåœ¨1/2å°ºåº¦ä¸Šï¼Œæ©è†œéœ€åŒæ­¥resizeä¸€æ¬¡
        let mut mask_edge_half = core::Mat::default();
        let mut mask_outer_half = core::Mat::default();
        imgproc::resize(mask_edgeband_full, &mut mask_edge_half, roi_grad_half.size()?, 0.0, 0.0, imgproc::INTER_NEAREST)?;
        imgproc::resize(mask_outer_full, &mut mask_outer_half, roi_grad_half.size()?, 0.0, 0.0, imgproc::INTER_NEAREST)?;
        
        // (1) edge bandç›´æ–¹å›¾ -> P90
        let hist_size = core::Vector::<i32>::from(vec![32]);
        let ranges = core::Vector::<f32>::from(vec![0f32, 255f32]);
        let channels = core::Vector::<i32>::from(vec![0]);
        let mut hist = core::Mat::default();
        let images = core::Vector::<core::Mat>::from(vec![roi_grad_half.clone()]);
        imgproc::calc_hist(&images, &channels, &mask_edge_half, &mut hist, &hist_size, &ranges, false)?;
        
        let total = core::sum_elems(&hist)?[0] as f32;
        let mut acc = 0f32;
        let mut p90_bin = 31;
        for b in 0..32 {
            acc += *hist.at::<f32>(b)?;
            if acc >= 0.9 * total {
                p90_bin = b;
                break;
            }
        }
        let p90 = (p90_bin as f32 + 0.5) * (255.0 / 32.0);
        
        // (2) å¤–ç¯stddevï¼ˆè¶³å¤Ÿå¿«ï¼‰
        let mut mean_v = core::Scalar::default();
        let mut std_v = core::Scalar::default();
        core::mean_std_dev(roi_grad_half, &mut mean_v, &mut std_v, &mask_outer_half)?;
        let sigma = std_v[0].max(1e-3);
        
        Ok((p90 as f64) / sigma)
    }
    
    /// ğŸš€ V3.2: å¿«é€ŸDTç»†åŒ–ï¼ˆå¤ç”¨å·²æœ‰å®ç°ï¼›ç¡®ä¿è½»é‡ï¼‰
    fn refine_dt_fast_reuse(
        roi_gray: &core::Mat,
        rr: core::Rect,
        kernel3: &core::Mat,
        r0: f32,
    ) -> Result<core::Point2f, opencv::Error> {
        // ç”¨"å±€éƒ¨é˜ˆå€¼ t_local = (mu_in + mu_ring)/2"å³å¯ï¼›é¿å…å¤šæ¬¡æ©è†œç»Ÿè®¡
        let t_local = {
            let mut mean_all = core::Scalar::default();
            let mut std_all = core::Scalar::default();
            core::mean_std_dev(roi_gray, &mut mean_all, &mut std_all, &core::Mat::default())?;
            mean_all[0] + 0.25 * std_all[0] // éå¸¸å¿«çš„è¿‘ä¼¼é—¨é™
        };
        
        let mut bin = core::Mat::default();
        imgproc::threshold(roi_gray, &mut bin, t_local, 255.0, imgproc::THRESH_BINARY)?;
        let mut eroded = core::Mat::default();
        imgproc::erode(&bin, &mut eroded, kernel3, core::Point::new(-1, -1), 1, core::BORDER_CONSTANT, imgproc::morphology_default_border_value()?)?;
        
        let mut dist = core::Mat::default();
        imgproc::distance_transform(&eroded, &mut dist, imgproc::DIST_L2, 3, core::CV_32F)?;
        
        // å³°å€¼ + 3Ã—3äºŒæ¬¡æ›²é¢
        let mut max_val = 0.0;
        let mut max_loc = core::Point::default();
        core::min_max_loc(&dist, None, Some(&mut max_val), None, Some(&mut max_loc), &core::Mat::default())?;
        
        let (sx, sy) = Self::quadfit_subpixel_3x3(&dist, max_loc)?;
        Ok(core::Point2f::new(rr.x as f32 + sx, rr.y as f32 + sy))
    }
    
    /// ğŸš€ V3.2: ROIè®¡ç®—è¾…åŠ©å‡½æ•°
    fn roi_at(c0: core::Point2f, roi_side: i32, img_cols: i32, img_rows: i32) -> core::Rect {
        let x0 = ((c0.x as i32) - roi_side / 2).clamp(0, img_cols - roi_side);
        let y0 = ((c0.y as i32) - roi_side / 2).clamp(0, img_rows - roi_side);
        core::Rect::new(x0, y0, roi_side, roi_side)
    }
    
    /// ğŸš€ V3.2: 1/2å°ºåº¦ROIè®¡ç®—
    fn rect_half(rr: core::Rect) -> core::Rect {
        core::Rect::new(rr.x / 2, rr.y / 2, rr.width / 2, rr.height / 2)
    }
    
    /// ğŸš€ V3.2: ä½ç§»ä¿æŠ¤ï¼ˆå†…è”ä¼˜åŒ–ï¼‰
    fn push_with_guard(
        c0: core::Point2f,
        c: core::Point2f,
        max_disp: f32,
        out: &mut core::Vector<core::Point2f>,
        tags: &mut Vec<RefineTag>,
        n_fb: &mut i32,
        tag: RefineTag,
    ) {
        let d = ((c.x - c0.x).powi(2) + (c.y - c0.y).powi(2)).sqrt();
        if d > max_disp {
            out.push(c0);
            tags.push(RefineTag::Fallback);
            *n_fb += 1;
        } else {
            out.push(c);
            tags.push(tag);
        }
    }
    
    /// ğŸš€ V3: æå–æ©è†œåŒºåŸŸçš„åƒç´ å€¼
    fn masked_values_f32(mat: &core::Mat, mask: &core::Mat) -> Result<Vec<f32>, opencv::Error> {
        let mut vals = Vec::new();
        for y in 0..mat.rows() {
            for x in 0..mat.cols() {
                if *mask.at_2d::<u8>(y, x)? != 0 {
                    vals.push(*mat.at_2d::<f32>(y, x)?);
                }
            }
        }
        Ok(vals)
    }
    
    /// ğŸš€ V3: è®¡ç®—ä¸­ä½æ•°å’ŒMAD
    fn median_and_mad(vals: &[f32]) -> (f32, f32) {
        if vals.is_empty() {
            return (0.0, 0.0);
        }
        
        let mut sorted = vals.to_vec();
        sorted.sort_by(|a, b| a.partial_cmp(b).unwrap());
        
        let med = sorted[sorted.len() / 2];
        
        // MAD
        let mut dev: Vec<f32> = sorted.iter().map(|v| (v - med).abs()).collect();
        dev.sort_by(|a, b| a.partial_cmp(b).unwrap());
        let mad = dev[dev.len() / 2];
        
        (med, mad)
    }
    
    /// ğŸš€ V3: é«˜ç½®ä¿¡DT-onlyç»†åŒ–ï¼ˆæå¿«ï¼‰
    fn refine_bright_fast_dt(
        roi: &core::Mat,
        masks: &PrecomputedMasks,
        se3: &core::Mat,
        roi_rect: core::Rect,
        c0: core::Point2f,
        rin: f32,
    ) -> Result<core::Point2f, opencv::Error> {
        // å±€éƒ¨é˜ˆå€¼ï¼šç”¨ç¯åŸŸä¸å†…ç›˜å‡å€¼çš„ä¸­ç‚¹ï¼ˆæ©è†œå¤ç”¨ï¼‰
        let mu_in = core::mean(roi, &masks.inner_mask_u8)?[0];
        let mu_ring = core::mean(roi, &masks.ring_mask_u8)?[0];
        let t = mu_ring + 0.5 * (mu_in - mu_ring);
        
        let mut bw = core::Mat::default();
        imgproc::threshold(roi, &mut bw, t, 255.0, imgproc::THRESH_BINARY)?;
        
        let mut bw_erode = core::Mat::default();
        imgproc::erode(&bw, &mut bw_erode, se3, core::Point::new(-1, -1), 1, core::BORDER_CONSTANT, imgproc::morphology_default_border_value()?)?;
        
        let mut dist = core::Mat::default();
        imgproc::distance_transform(&bw_erode, &mut dist, imgproc::DIST_L2, 3, core::CV_32F)?;
        
        // ä»…åœ¨ä¸­å¿ƒå°åœ†å†…æ‰¾å³°å€¼ï¼ˆé¿å…å™ªå£°ï¼‰ï¼šåŠå¾„â‰ˆ0.8*rin
        let mut peak_mask = core::Mat::default();
        masks.center_mask(&mut peak_mask)?;
        
        let (pv, pl) = Self::max_loc_masked_32f(&dist, &peak_mask)?;
        
        if pv <= 2.0 {
            return Ok(c0); // å¾ˆæ·¡ç›´æ¥å›é€€
        }
        
        // ğŸš€ 3Ã—3äºŒæ¬¡æ›²é¢äºšåƒç´ æ‹Ÿåˆï¼ˆæå¿«ï¼‰
        let (subx, suby) = Self::quadfit_subpixel_3x3(&dist, pl)?;
        Ok(core::Point2f::new(roi_rect.x as f32 + subx, roi_rect.y as f32 + suby))
    }
    
    /// ğŸš€ V3: æ©è†œåŒºåŸŸå†…æ‰¾æœ€å¤§å€¼å’Œä½ç½®
    fn max_loc_masked_32f(mat: &core::Mat, mask: &core::Mat) -> Result<(f32, core::Point), opencv::Error> {
        let mut max_val = 0.0f32;
        let mut max_loc = core::Point::new(0, 0);
        
        for y in 0..mat.rows() {
            for x in 0..mat.cols() {
                if *mask.at_2d::<u8>(y, x)? != 0 {
                    let val = *mat.at_2d::<f32>(y, x)?;
                    if val > max_val {
                        max_val = val;
                        max_loc = core::Point::new(x, y);
                    }
                }
            }
        }
        
        Ok((max_val, max_loc))
    }
    
    /// ğŸš€ V3: 3Ã—3äºŒæ¬¡æ›²é¢äºšåƒç´ æ‹Ÿåˆ
    fn quadfit_subpixel_3x3(mat: &core::Mat, center: core::Point) -> Result<(f32, f32), opencv::Error> {
        let x = center.x;
        let y = center.y;
        
        // è¾¹ç•Œæ£€æŸ¥
        if x < 1 || y < 1 || x >= mat.cols() - 1 || y >= mat.rows() - 1 {
            return Ok((x as f32, y as f32));
        }
        
        // 3Ã—3é‚»åŸŸ
        let f00 = *mat.at_2d::<f32>(y - 1, x - 1)?;
        let f01 = *mat.at_2d::<f32>(y - 1, x)?;
        let f02 = *mat.at_2d::<f32>(y - 1, x + 1)?;
        let f10 = *mat.at_2d::<f32>(y, x - 1)?;
        let f11 = *mat.at_2d::<f32>(y, x)?;
        let f12 = *mat.at_2d::<f32>(y, x + 1)?;
        let f20 = *mat.at_2d::<f32>(y + 1, x - 1)?;
        let f21 = *mat.at_2d::<f32>(y + 1, x)?;
        let f22 = *mat.at_2d::<f32>(y + 1, x + 1)?;
        
        // äºŒé˜¶å¯¼æ•°
        let fxx = f10 - 2.0 * f11 + f12;
        let fyy = f01 - 2.0 * f11 + f21;
        let fxy = 0.25 * (f00 - f02 - f20 + f22);
        
        // ä¸€é˜¶å¯¼æ•°
        let fx = 0.5 * (f12 - f10);
        let fy = 0.5 * (f21 - f01);
        
        // æ±‚è§£äºšåƒç´ åç§»
        let det = fxx * fyy - fxy * fxy;
        if det.abs() < 1e-6 {
            return Ok((x as f32, y as f32));
        }
        
        let dx = -(fyy * fx - fxy * fy) / det;
        let dy = -(fxx * fy - fxy * fx) / det;
        
        // é™åˆ¶åç§»èŒƒå›´
        let dx = dx.clamp(-0.5, 0.5);
        let dy = dy.clamp(-0.5, 0.5);
        
        Ok((x as f32 + dx, y as f32 + dy))
    }
    
    /// ğŸš€ V3.1: ç®€åŒ–DT-onlyç»†åŒ–ï¼ˆæ— é¢„è®¡ç®—æ©è†œï¼‰
    fn refine_bright_fast_dt_v31(
        roi: &core::Mat,
        roi_rect: core::Rect,
        r0: f32,
    ) -> Result<core::Point2f, opencv::Error> {
        let cx = roi.cols() as f32 * 0.5;
        let cy = roi.rows() as f32 * 0.5;
        
        // å±€éƒ¨é˜ˆå€¼ï¼šå†…ç›˜ä¸ç¯åŸŸå‡å€¼çš„ä¸­ç‚¹
        let (mu_in, mu_ring, _) = Self::mean_and_sigma_in_ring(roi, 0.8 * r0, 1.0 * r0, 1.3 * r0)?;
        let t = mu_ring + 0.5 * (mu_in - mu_ring);
        
        let mut bw = core::Mat::default();
        imgproc::threshold(roi, &mut bw, t, 255.0, imgproc::THRESH_BINARY)?;
        
        // è½»å¾®è…èš€
        let se3 = imgproc::get_structuring_element(imgproc::MORPH_ELLIPSE, core::Size::new(3, 3), core::Point::new(-1, -1))?;
        let mut bw_erode = core::Mat::default();
        imgproc::erode(&bw, &mut bw_erode, &se3, core::Point::new(-1, -1), 1, core::BORDER_CONSTANT, imgproc::morphology_default_border_value()?)?;
        
        let mut dist = core::Mat::default();
        imgproc::distance_transform(&bw_erode, &mut dist, imgproc::DIST_L2, 3, core::CV_32F)?;
        
        // åœ¨ä¸­å¿ƒå°åœ†å†…æ‰¾å³°å€¼
        let search_r = (0.8 * r0) as i32;
        let mut max_val = 0.0f32;
        let mut max_loc = core::Point::new(cx as i32, cy as i32);
        
        for y in ((cy as i32) - search_r).max(0)..((cy as i32) + search_r).min(roi.rows()) {
            for x in ((cx as i32) - search_r).max(0)..((cx as i32) + search_r).min(roi.cols()) {
                let dx = x as f32 - cx;
                let dy = y as f32 - cy;
                if dx * dx + dy * dy <= (search_r as f32).powi(2) {
                    let val = *dist.at_2d::<f32>(y, x)?;
                    if val > max_val {
                        max_val = val;
                        max_loc = core::Point::new(x, y);
                    }
                }
            }
        }
        
        if max_val <= 2.0 {
            return Ok(core::Point2f::new(roi_rect.x as f32 + cx, roi_rect.y as f32 + cy));
        }
        
        // 3Ã—3äºŒæ¬¡æ›²é¢äºšåƒç´ æ‹Ÿåˆ
        let (subx, suby) = Self::quadfit_subpixel_3x3(&dist, max_loc)?;
        Ok(core::Point2f::new(roi_rect.x as f32 + subx, roi_rect.y as f32 + suby))
    }
    
    /// ğŸš€ V3.1: å¿«é€Ÿå¾„å‘é‡‡æ ·ï¼ˆé™é‡‡æ ·ç‰ˆæœ¬ï¼‰
    fn refine_dark_radial_fit_fast(
        roi: &core::Mat,
        roi_rect: core::Rect,
        polar: &PolarTable,
        rin: f32,
        rout: f32,
        r0: f32,
        radial_step: f32,
    ) -> Result<(bool, core::Point2f), opencv::Error> {
        // Scharræ¢¯åº¦
        let mut gx = core::Mat::default();
        let mut gy = core::Mat::default();
        imgproc::scharr(roi, &mut gx, core::CV_32F, 1, 0, 1.0, 0.0, core::BORDER_DEFAULT)?;
        imgproc::scharr(roi, &mut gy, core::CV_32F, 0, 1, 1.0, 0.0, core::BORDER_DEFAULT)?;
        
        let mut mag = core::Mat::default();
        core::magnitude(&gx, &gy, &mut mag)?;
        
        let cx = (roi.cols() as f32) * 0.5;
        let cy = (roi.rows() as f32) * 0.5;
        
        let mut pts = Vec::<(f32, f32, f32)>::new(); // (x, y, w=grad)
        
        for k in 0..polar.n {
            let (cs, sn) = (polar.cos[k], polar.sin[k]);
            
            // æ²¿åŠå¾„é‡‡æ ·ï¼Œåœ¨[rin, rout]å¯»æ‰¾æœ€å¤§æ¢¯åº¦ä½ç½®
            let mut best = (0f32, 0f32, 0f32); // (x, y, mag)
            let mut r = rin;
            while r <= rout {
                let x = cx + r * cs;
                let y = cy + r * sn;
                let g = Self::bilinear_at_f32(&mag, x, y)?; // åŒçº¿æ€§å–å€¼
                if g > best.2 {
                    best = (x, y, g);
                }
                r += radial_step; // ä½¿ç”¨ä¼ å…¥çš„æ­¥é•¿
            }
            if best.2 > 0.0 {
                pts.push(best);
            }
        }
        
        // è¦†ç›–åº¦ï¼šâ‰¥150Â°ä¸”â‰¥3ä¸ªè±¡é™
        if !Self::angle_coverage_ok(&pts, cx, cy) {
            return Ok((false, core::Point2f::new(0.0, 0.0)));
        }
        
        // Pratt/Taubinè½»é‡æ‹Ÿåˆï¼ˆæƒé‡=æ¢¯åº¦ï¼‰
        if let Some((xc, yc, rad)) = Self::pratt_fit_weighted(&pts) {
            if rad < 0.85 * r0 || rad > 1.15 * r0 {
                return Ok((false, core::Point2f::new(0.0, 0.0)));
            }
            return Ok((true, core::Point2f::new(roi_rect.x as f32 + xc, roi_rect.y as f32 + yc)));
        }
        
        Ok((false, core::Point2f::new(0.0, 0.0)))
    }
    
    /// ğŸš€ V3: ä½ç½®ä¿¡å¾„å‘é‡‡æ ·+è½»é‡åœ†æ‹Ÿåˆï¼ˆæ— contoursï¼Œæ— Houghï¼‰
    fn refine_dark_radial_fit(
        roi: &core::Mat,
        roi_rect: core::Rect,
        polar: &PolarTable,
        rin: f32,
        rout: f32,
        r0: f32,
    ) -> Result<(bool, core::Point2f), opencv::Error> {
        // å…ˆç®—ä¸€æ¬¡Scharrå¹¶ç¼“å­˜
        let mut gx = core::Mat::default();
        let mut gy = core::Mat::default();
        imgproc::scharr(roi, &mut gx, core::CV_32F, 1, 0, 1.0, 0.0, core::BORDER_DEFAULT)?;
        imgproc::scharr(roi, &mut gy, core::CV_32F, 0, 1, 1.0, 0.0, core::BORDER_DEFAULT)?;
        
        let mut mag = core::Mat::default();
        core::magnitude(&gx, &gy, &mut mag)?;
        
        let cx = (roi.cols() as f32) * 0.5;
        let cy = (roi.rows() as f32) * 0.5;
        
        let mut pts = Vec::<(f32, f32, f32)>::new(); // (x, y, w=grad)
        
        for k in 0..polar.n {
            let (cs, sn) = (polar.cos[k], polar.sin[k]);
            
            // æ²¿åŠå¾„é‡‡æ ·ï¼Œåœ¨[rin, rout]å¯»æ‰¾æœ€å¤§æ¢¯åº¦ä½ç½®
            let mut best = (0f32, 0f32, 0f32); // (x, y, mag)
            let mut r = rin;
            while r <= rout {
                let x = cx + r * cs;
                let y = cy + r * sn;
                let g = Self::bilinear_at_f32(&mag, x, y)?; // åŒçº¿æ€§å–å€¼
                if g > best.2 {
                    best = (x, y, g);
                }
                r += 0.6; // æ­¥é•¿~0.6pxè¶³å¤Ÿ
            }
            if best.2 > 0.0 {
                pts.push(best);
            }
        }
        
        // è¦†ç›–åº¦ï¼šâ‰¥150Â°ä¸”â‰¥3ä¸ªè±¡é™
        if !Self::angle_coverage_ok(&pts, cx, cy) {
            return Ok((false, core::Point2f::new(0.0, 0.0)));
        }
        
        // Pratt/Taubinè½»é‡æ‹Ÿåˆï¼ˆæƒé‡=æ¢¯åº¦ï¼‰
        if let Some((xc, yc, rad)) = Self::pratt_fit_weighted(&pts) {
            if rad < 0.85 * r0 || rad > 1.15 * r0 {
                return Ok((false, core::Point2f::new(0.0, 0.0)));
            }
            return Ok((true, core::Point2f::new(roi_rect.x as f32 + xc, roi_rect.y as f32 + yc)));
        }
        
        Ok((false, core::Point2f::new(0.0, 0.0)))
    }
    
    /// ğŸš€ V3: åŒçº¿æ€§æ’å€¼å–å€¼
    fn bilinear_at_f32(mat: &core::Mat, x: f32, y: f32) -> Result<f32, opencv::Error> {
        let x0 = x.floor() as i32;
        let y0 = y.floor() as i32;
        let x1 = x0 + 1;
        let y1 = y0 + 1;
        
        // è¾¹ç•Œæ£€æŸ¥
        if x0 < 0 || y0 < 0 || x1 >= mat.cols() || y1 >= mat.rows() {
            return Ok(0.0);
        }
        
        let fx = x - x0 as f32;
        let fy = y - y0 as f32;
        
        let f00 = *mat.at_2d::<f32>(y0, x0)?;
        let f01 = *mat.at_2d::<f32>(y0, x1)?;
        let f10 = *mat.at_2d::<f32>(y1, x0)?;
        let f11 = *mat.at_2d::<f32>(y1, x1)?;
        
        let f0 = f00 * (1.0 - fx) + f01 * fx;
        let f1 = f10 * (1.0 - fx) + f11 * fx;
        let result = f0 * (1.0 - fy) + f1 * fy;
        
        Ok(result)
    }
    
    /// ğŸš€ V3: è§’è¦†ç›–åº¦æ£€æŸ¥
    fn angle_coverage_ok(pts: &[(f32, f32, f32)], cx: f32, cy: f32) -> bool {
        if pts.len() < 20 {
            return false;
        }
        
        let mut angles: Vec<f32> = pts.iter()
            .map(|(x, y, _)| (y - cy).atan2(x - cx))
            .collect();
        angles.sort_by(|a, b| a.partial_cmp(b).unwrap());
        
        // è®¡ç®—æœ€å¤§é—´éš™
        let mut max_gap = 0.0f32;
        for i in 0..angles.len() {
            let a = angles[i];
            let b = if i + 1 < angles.len() {
                angles[i + 1]
            } else {
                angles[0] + 2.0 * std::f32::consts::PI
            };
            let gap = (b - a).to_degrees();
            if gap > max_gap {
                max_gap = gap;
            }
        }
        
        let coverage = (360.0 - max_gap).max(0.0);
        
        // è±¡é™è¦†ç›–æ£€æŸ¥
        let mut quadrants = [false; 4];
        for (x, y, _) in pts {
            let dx = x - cx;
            let dy = y - cy;
            let quad = if dx >= 0.0 && dy >= 0.0 { 0 }
                      else if dx < 0.0 && dy >= 0.0 { 1 }
                      else if dx < 0.0 && dy < 0.0 { 2 }
                      else { 3 };
            quadrants[quad] = true;
        }
        let quad_count = quadrants.iter().filter(|&&x| x).count();
        
        coverage >= 150.0 && quad_count >= 3
    }
    
    /// ğŸš€ V3: PrattåŠ æƒåœ†æ‹Ÿåˆ
    fn pratt_fit_weighted(pts: &[(f32, f32, f32)]) -> Option<(f32, f32, f32)> {
        if pts.len() < 5 {
            return None;
        }
        
        // ç®€åŒ–å®ç°ï¼šä½¿ç”¨æœ€å°äºŒä¹˜æ³•æ‹Ÿåˆåœ†
        // æ–¹ç¨‹: (x-a)Â² + (y-b)Â² = rÂ²
        // å±•å¼€: xÂ² + yÂ² - 2ax - 2by + (aÂ²+bÂ²-rÂ²) = 0
        // è®¾ A = -2a, B = -2b, C = aÂ²+bÂ²-rÂ²
        // åˆ™: xÂ² + yÂ² + Ax + By + C = 0
        
        let n = pts.len() as f32;
        let mut sum_x = 0.0f32;
        let mut sum_y = 0.0f32;
        let mut sum_x2 = 0.0f32;
        let mut sum_y2 = 0.0f32;
        let mut sum_xy = 0.0f32;
        let mut sum_x3 = 0.0f32;
        let mut sum_y3 = 0.0f32;
        let mut sum_x2y = 0.0f32;
        let mut sum_xy2 = 0.0f32;
        let mut sum_w = 0.0f32;
        
        for &(x, y, w) in pts {
            let w = w.max(0.1); // é¿å…æƒé‡ä¸º0
            sum_w += w;
            sum_x += w * x;
            sum_y += w * y;
            sum_x2 += w * x * x;
            sum_y2 += w * y * y;
            sum_xy += w * x * y;
            sum_x3 += w * x * x * x;
            sum_y3 += w * y * y * y;
            sum_x2y += w * x * x * y;
            sum_xy2 += w * x * y * y;
        }
        
        // å½’ä¸€åŒ–
        sum_x /= sum_w;
        sum_y /= sum_w;
        sum_x2 /= sum_w;
        sum_y2 /= sum_w;
        sum_xy /= sum_w;
        sum_x3 /= sum_w;
        sum_y3 /= sum_w;
        sum_x2y /= sum_w;
        sum_xy2 /= sum_w;
        
        // æ„å»ºçº¿æ€§æ–¹ç¨‹ç»„æ±‚è§£A, B
        let m11 = sum_x2;
        let m12 = sum_xy;
        let m21 = sum_xy;
        let m22 = sum_y2;
        
        let v1 = sum_x3 + sum_xy2;
        let v2 = sum_y3 + sum_x2y;
        
        let det = m11 * m22 - m12 * m21;
        if det.abs() < 1e-6 {
            return None;
        }
        
        let a = -(m22 * v1 - m12 * v2) / det / 2.0;
        let b = -(m11 * v2 - m21 * v1) / det / 2.0;
        
        // è®¡ç®—åŠå¾„
        let c = sum_x2 + sum_y2 + 2.0 * a * sum_x + 2.0 * b * sum_y;
        let r_sq = a * a + b * b - c;
        
        if r_sq <= 0.0 {
            return None;
        }
        
        let r = r_sq.sqrt();
        Some((a, b, r))
    }
    
    /// ğŸ”† V3: DTåˆå€¼ + è¾¹ç•Œçº¦æŸåœ†æ‹Ÿåˆ - è§£å†³å‘é˜µåˆ—ä¸­å¿ƒåç§» (å·²å¼ƒç”¨ï¼Œè¢«ç²¾ç®€ç‰ˆæœ¬æ›¿ä»£)
    #[allow(dead_code)]
    fn refine_dt_with_boundary_fit(
        roi: &core::Mat,
        roi_rect: core::Rect,
        original_center: core::Point2f,
        r0: f32,        // å…ˆéªŒåŠå¾„ â‰ˆ D_nom/2
        rin: f32,       // ~0.8 r0
        rout: f32,      // ~1.25 r0
    ) -> Result<core::Point2f, opencv::Error> {
        let center_roi = core::Point::new(roi.cols() / 2, roi.rows() / 2);
        
        // A) å±€éƒ¨é˜ˆå€¼ + å°ä¿®æ•´ï¼Œå¾—åˆ°DTæ©è†œ
        let (binary, _t_local) = Self::dt_mask_from_local_threshold(roi, r0)?;
        let mut dist = core::Mat::default();
        imgproc::distance_transform(&binary, &mut dist, imgproc::DIST_L2, 3, core::CV_32F)?;
        
        // åœ¨0.8*r0å†…æ‰¾DTå³°ï¼ˆåˆå€¼ï¼‰
        let mut peak_mask = core::Mat::zeros(roi.rows(), roi.cols(), core::CV_8U)?.to_mat()?;
        let r_search = (0.8 * 0.9 * r0) as i32; // ç¨å¾®ä¿å®ˆ
        imgproc::circle(&mut peak_mask, center_roi, r_search, core::Scalar::all(255.0), -1, imgproc::LINE_8, 0)?;
        
        let mut min_v = 0.0;
        let mut max_v = 0.0;
        let mut min_l = core::Point::default();
        let mut max_l = core::Point::default();
        core::min_max_loc(&dist, Some(&mut min_v), Some(&mut max_v), Some(&mut min_l), Some(&mut max_l), &peak_mask)?;
        
        let c_dt = core::Point2f::new(max_l.x as f32 + 0.5, max_l.y as f32 + 0.5);
        if max_v <= 2.0 {
            // DTå³°ä¸å¯é ï¼Œç›´æ¥å›é€€
            return Ok(original_center);
        }
        
        // B) è§’åº¦é‡‡æ ·æ‰¾è¾¹ï¼ˆä»…åŠç¯åŸŸï¼›è½»é‡ï¼‰
        let edge_pts = Self::radial_edge_points(roi, c_dt, rin, rout, 6.0)?; // æ¯6Â°å–æ ·
        if edge_pts.len() < 20 {
            // è¾¹å¤ªå¼±ï¼Œå›é€€åˆ°DT
            return Ok(core::Point2f::new(roi_rect.x as f32 + c_dt.x, roi_rect.y as f32 + c_dt.y));
        }
        
        // è§’è¦†ç›–æ£€æŸ¥ï¼ˆé¿å…åŠè¾¹ï¼‰
        let ang_cov = Self::angular_coverage(&edge_pts, c_dt);
        if ang_cov < 150.0 {
            return Ok(core::Point2f::new(roi_rect.x as f32 + c_dt.x, roi_rect.y as f32 + c_dt.y));
        }
        
        // C) æœ€å°å¤–æ¥åœ†ï¼ˆè¿‘ä¼¼é²æ£’ï¼›å·²ç­›å¼±ç‚¹ï¼‰
        let mut pts_i32 = core::Vector::<core::Point>::new();
        for p in &edge_pts {
            pts_i32.push(core::Point::new(p.x.round() as i32, p.y.round() as i32));
        }
        
        let mut c_fit = core::Point2f::default();
        let mut r_fit = 0.0f32;
        imgproc::min_enclosing_circle(&pts_i32, &mut c_fit, &mut r_fit)?;
        
        // åŠå¾„/ä½ç§»åˆç†æ€§
        if r_fit < 0.85 * r0 || r_fit > 1.20 * r0 {
            return Ok(core::Point2f::new(roi_rect.x as f32 + c_dt.x, roi_rect.y as f32 + c_dt.y));
        }
        
        // è¿”å›åˆ°å…¨å›¾åæ ‡
        Ok(core::Point2f::new(roi_rect.x as f32 + c_fit.x, roi_rect.y as f32 + c_fit.y))
    }
    
    /// ğŸ”§ V3: å±€éƒ¨é˜ˆå€¼ + å°ä¿®æ•´ï¼ˆDTæ©è†œï¼‰(å·²å¼ƒç”¨)
    #[allow(dead_code)]
    fn dt_mask_from_local_threshold(
        roi: &core::Mat,
        r0: f32,
    ) -> Result<(core::Mat, f64), opencv::Error> {
        let center = core::Point::new(roi.cols() / 2, roi.rows() / 2);
        
        // å†…ç›˜/ç¯åŸŸå‡å€¼ï¼ˆä¸ç°æœ‰ä¸€è‡´ï¼‰
        let mut in_mask = core::Mat::zeros(roi.rows(), roi.cols(), core::CV_8U)?.to_mat()?;
        imgproc::circle(&mut in_mask, center, (0.45 * r0 * 2.0) as i32, core::Scalar::all(255.0), -1, imgproc::LINE_8, 0)?;
        let mu_in = core::mean(roi, &in_mask)?[0];
        
        let mut ring = core::Mat::zeros(roi.rows(), roi.cols(), core::CV_8U)?.to_mat()?;
        imgproc::circle(&mut ring, center, (0.90 * r0 * 2.0) as i32, core::Scalar::all(255.0), -1, imgproc::LINE_8, 0)?;
        imgproc::circle(&mut ring, center, (0.65 * r0 * 2.0) as i32, core::Scalar::all(0.0), -1, imgproc::LINE_8, 0)?;
        let mu_ring = core::mean(roi, &ring)?[0];
        
        let t_local = mu_ring + 0.5 * (mu_in - mu_ring);
        
        let mut bin = core::Mat::default();
        imgproc::threshold(roi, &mut bin, t_local, 255.0, imgproc::THRESH_BINARY)?;
        
        // è½»åº¦å½¢æ€å­¦ä¿®æ•´ï¼ˆè®©å£³å±‚æ›´åœ†æ¶¦ï¼ŒæŠ‘åˆ¶DTåç§»ï¼‰
        let se_size = ((0.06 * 2.0 * r0) as i32).max(3) | 1; // ç¡®ä¿å¥‡æ•°
        let se_close = imgproc::get_structuring_element(
            imgproc::MORPH_ELLIPSE,
            core::Size::new(se_size, se_size),
            core::Point::new(-1, -1)
        )?;
        let mut closed = core::Mat::default();
        imgproc::morphology_ex(&bin, &mut closed, imgproc::MORPH_CLOSE, &se_close, 
                              core::Point::new(-1, -1), 1, core::BORDER_CONSTANT, 
                              imgproc::morphology_default_border_value()?)?;
        
        Ok((closed, t_local))
    }
    
    /// ğŸ” V3: å¾„å‘å¯»è¾¹ (å·²å¼ƒç”¨)
    #[allow(dead_code)]
    fn radial_edge_points(
        roi: &core::Mat,
        c0: core::Point2f, // åˆå€¼ä¸­å¿ƒï¼ˆDTï¼‰
        rin: f32,
        rout: f32,
        step_deg: f32,
    ) -> Result<Vec<core::Point2f>, opencv::Error> {
        // Sobelæ¢¯åº¦
        let mut gx = core::Mat::default();
        let mut gy = core::Mat::default();
        imgproc::sobel(roi, &mut gx, core::CV_32F, 1, 0, 3, 1.0, 0.0, core::BORDER_DEFAULT)?;
        imgproc::sobel(roi, &mut gy, core::CV_32F, 0, 1, 3, 1.0, 0.0, core::BORDER_DEFAULT)?;
        
        let mut candidates = Vec::<(core::Point2f, f32, f32)>::new(); // (pt, grad_rad, theta)
        
        let mut theta = 0.0f32;
        while theta < 360.0 {
            let th = theta.to_radians();
            let ux = th.cos();
            let uy = th.sin();
            
            // åœ¨[rin, rout]æœç´¢å¾„å‘æœ€å¤§æ¢¯åº¦ï¼ˆæ–¹å‘ä¸å¾„å‘åŒå‘ï¼‰
            let mut best_g = 0.0f32;
            let mut best_p = None::<core::Point2f>;
            let mut r = rin;
            while r <= rout {
                let x = (c0.x + r * ux).round() as i32;
                let y = (c0.y + r * uy).round() as i32;
                if x >= 1 && x < roi.cols() - 1 && y >= 1 && y < roi.rows() - 1 {
                    let gxv = *gx.at_2d::<f32>(y, x)?;
                    let gyv = *gy.at_2d::<f32>(y, x)?;
                    let g_rad = gxv * ux + gyv * uy; // å¾„å‘åˆ†é‡
                    if g_rad > best_g {
                        best_g = g_rad;
                        best_p = Some(core::Point2f::new(x as f32, y as f32));
                    }
                }
                r += 1.0;
            }
            
            if let Some(p) = best_p {
                candidates.push((p, best_g, theta));
            }
            theta += step_deg;
        }
        
        if candidates.is_empty() {
            return Ok(vec![]);
        }
        
        // ä»¥åˆ†ä½æ•°å»å¼±ï¼ˆQ70ï¼‰
        let mut gvals: Vec<f32> = candidates.iter().map(|(_, g, _)| *g).collect();
        gvals.sort_by(|a, b| a.partial_cmp(b).unwrap());
        let q70 = gvals[(0.7 * (gvals.len() - 1) as f32) as usize].max(1e-3);
        
        let mut pts = Vec::<core::Point2f>::new();
        for (p, g, _) in candidates {
            if g >= q70 {
                pts.push(p);
            }
        }
        Ok(pts)
    }
    
    /// ğŸ“ V3: è§’è¦†ç›–åº¦ï¼ˆé¿å…å•ä¾§ç‚¹ï¼‰(å·²å¼ƒç”¨)
    #[allow(dead_code)]
    fn angular_coverage(pts: &Vec<core::Point2f>, c: core::Point2f) -> f32 {
        if pts.len() < 2 {
            return 0.0;
        }
        let mut angs: Vec<f32> = pts.iter().map(|p| (p.y - c.y).atan2(p.x - c.x)).collect();
        angs.sort_by(|a, b| a.partial_cmp(b).unwrap());
        
        // è®¡ç®—åœ†å‘¨ä¸Šæœ€å¤§é—´éš™ï¼Œè¦†ç›–=360Â°-æœ€å¤§é—´éš™
        let mut max_gap = 0.0f32;
        for i in 0..angs.len() {
            let a = angs[i];
            let b = if i + 1 < angs.len() {
                angs[i + 1]
            } else {
                angs[0] + std::f32::consts::TAU
            };
            let gap = (b - a).to_degrees();
            if gap > max_gap {
                max_gap = gap;
            }
        }
        (360.0 - max_gap).max(0.0)
    }
    
    /// ğŸ¨ V3: ç»˜åˆ¶ç»†åŒ–æ¥æºdebugæ ‡è®°
    fn draw_refine_debug(
        dbg: &mut core::Mat,
        pt: core::Point2f,
        orig: core::Point2f,
        tag: RefineTag,
        scale_factor: f64
    ) -> Result<(), opencv::Error> {
        let (color, label) = match tag {
            RefineTag::Hi => (core::Scalar::new(50.0, 220.0, 50.0, 0.0), "H"),      // ç»¿è‰² - é«˜ç½®ä¿¡
            RefineTag::Lo => (core::Scalar::new(40.0, 180.0, 255.0, 0.0), "L"),     // æ©™è‰² - ä½ç½®ä¿¡
            RefineTag::Fallback => (core::Scalar::new(30.0, 30.0, 255.0, 0.0), "F"), // çº¢è‰² - å›é€€
        };
        
        let scaled_pt = core::Point::new(
            (pt.x as f64 * scale_factor) as i32,
            (pt.y as f64 * scale_factor) as i32
        );
        let scaled_orig = core::Point::new(
            (orig.x as f64 * scale_factor) as i32,
            (orig.y as f64 * scale_factor) as i32
        );
        
        // ç»˜åˆ¶ç»†åŒ–æ¥æºæ ‡è®°åœ†
        imgproc::circle(dbg, scaled_pt, (6.0 * scale_factor) as i32, color, 2, imgproc::LINE_8, 0)?;
        
        // ç»˜åˆ¶æ ‡ç­¾
        imgproc::put_text(dbg, label, 
            core::Point::new(scaled_pt.x + 8, scaled_pt.y - 8),
            imgproc::FONT_HERSHEY_SIMPLEX, 0.5 * scale_factor, color, 
            std::cmp::max(1, (1.0 * scale_factor) as i32), imgproc::LINE_AA, false)?;
        
        // ç»˜åˆ¶ä½ç§»å‘é‡ç®­å¤´
        if (scaled_pt.x - scaled_orig.x).abs() > 1 || (scaled_pt.y - scaled_orig.y).abs() > 1 {
            imgproc::arrowed_line(dbg, scaled_orig, scaled_pt, color, 
                std::cmp::max(1, (1.0 * scale_factor) as i32), imgproc::LINE_AA, 0, 0.25)?;
        }
        
        Ok(())
    }
    
    /// Asymmetric Gridæ’åº (åŸºäºgenerate_world_points_from_listçš„åæ ‡æ¨¡å¼)
    /// âš ï¸ æ³¨æ„ï¼šå½“å‰æ’åºç®—æ³•æœ‰ç´¢å¼•è¶Šç•Œé—®é¢˜ï¼Œæš‚æ—¶è·³è¿‡ä»¥ä¸“æ³¨äºåœ†ç‚¹æ£€æµ‹ä¼˜åŒ–
    pub fn sort_asymmetric_grid(&self, centers: &mut core::Vector<core::Point2f>) -> Result<(), opencv::Error> {
        if centers.len() != 40 {
            println!("âš ï¸ åœ†ç‚¹æ•°é‡ä¸æ˜¯40ä¸ªï¼Œè·³è¿‡æ’åº (å½“å‰: {}ä¸ª)", centers.len());
            return Ok(());
        }
        
        println!("âš ï¸ æ’åºåŠŸèƒ½æš‚æ—¶è·³è¿‡ - ä¸“æ³¨äºåœ†ç‚¹æ£€æµ‹ä¼˜åŒ–");
        println!("   å½“å‰æ£€æµ‹åˆ° {} ä¸ªåœ†ç‚¹ï¼Œæ’åºç®—æ³•å¾…ä¿®å¤", centers.len());
        
        // TODO: ä¿®å¤4è¡Œ10åˆ—çš„asymmetric gridæ’åºç®—æ³•
        // å½“å‰ç®—æ³•å­˜åœ¨ç´¢å¼•è¶Šç•Œé—®é¢˜ï¼Œéœ€è¦é‡æ–°è®¾è®¡
        // æ­£ç¡®çš„å¸ƒå±€åº”è¯¥æ˜¯ï¼š4è¡Œ10åˆ—ï¼Œè€Œä¸æ˜¯10è¡Œ4åˆ—
        
        Ok(())
    }
    
    /// ä¿å­˜å¸¦æ ‡æ³¨çš„debugå›¾åƒï¼ˆæ”¯æŒç¼©æ”¾æ˜¾ç¤ºï¼‰
    pub fn save_debug_image(
        &self, 
        image: &core::Mat, 
        centers: &core::Vector<core::Point2f>, 
        filename: &str
    ) -> Result<(), opencv::Error> {
        // è½¬æ¢ä¸ºå½©è‰²å›¾åƒ
        let mut debug_image = core::Mat::default();
        if image.channels() == 1 {
            imgproc::cvt_color(image, &mut debug_image, imgproc::COLOR_GRAY2BGR, 0, core::AlgorithmHint::ALGO_HINT_DEFAULT)?;
        } else {
            debug_image = image.clone();
        }
        
        // ğŸ¯ è®¡ç®—ç¼©æ”¾æ¯”ä¾‹ - è®©å›¾åƒæ›´å®¹æ˜“æŸ¥çœ‹
        let scale_factor = if debug_image.cols() > 1500 || debug_image.rows() > 1500 {
            0.5 // å¤§å›¾åƒç¼©æ”¾åˆ°50%
        } else {
            1.0 // å°å›¾åƒä¿æŒåŸå°ºå¯¸
        };
        
        // åº”ç”¨ç¼©æ”¾
        let mut scaled_image = core::Mat::default();
        if scale_factor != 1.0 {
            let new_size = core::Size::new(
                (debug_image.cols() as f64 * scale_factor) as i32,
                (debug_image.rows() as f64 * scale_factor) as i32,
            );
            imgproc::resize(&debug_image, &mut scaled_image, new_size, 0.0, 0.0, imgproc::INTER_LINEAR)?;
        } else {
            scaled_image = debug_image.clone();
        }
        
        // ç»˜åˆ¶æ£€æµ‹åˆ°çš„åœ†ç‚¹ï¼ˆæ ¹æ®ç¼©æ”¾è°ƒæ•´å¤§å°ï¼‰
        let circle_radius = (8.0 * scale_factor) as i32;
        let font_scale = 0.6 * scale_factor;
        let line_thickness = std::cmp::max(1, (2.0 * scale_factor) as i32);
        
        for i in 0..centers.len() {
            let point = centers.get(i)?;
            let scaled_x = (point.x as f64 * scale_factor) as i32;
            let scaled_y = (point.y as f64 * scale_factor) as i32;
            
            // ç»˜åˆ¶åœ†ç‚¹ (ç»¿è‰²ï¼Œæ›´å¤§æ›´æ˜æ˜¾)
            imgproc::circle(
                &mut scaled_image,
                core::Point::new(scaled_x, scaled_y),
                circle_radius,
                core::Scalar::new(0.0, 255.0, 0.0, 0.0), // ç»¿è‰²
                line_thickness,
                imgproc::LINE_8,
                0,
            )?;
            
            // ç»˜åˆ¶åœ†å¿ƒåå­—æ ‡è®° (çº¢è‰²)
            let cross_size = circle_radius / 2;
            imgproc::line(
                &mut scaled_image,
                core::Point::new(scaled_x - cross_size, scaled_y),
                core::Point::new(scaled_x + cross_size, scaled_y),
                core::Scalar::new(0.0, 0.0, 255.0, 0.0), // çº¢è‰²
                line_thickness,
                imgproc::LINE_8,
                0,
            )?;
            imgproc::line(
                &mut scaled_image,
                core::Point::new(scaled_x, scaled_y - cross_size),
                core::Point::new(scaled_x, scaled_y + cross_size),
                core::Scalar::new(0.0, 0.0, 255.0, 0.0), // çº¢è‰²
                line_thickness,
                imgproc::LINE_8,
                0,
            )?;
            
            // æ·»åŠ åºå·æ ‡æ³¨ (è“è‰²ï¼Œæ›´å¤§å­—ä½“)
            let text = format!("{}", i);
            imgproc::put_text(
                &mut scaled_image,
                &text,
                core::Point::new(scaled_x + circle_radius + 5, scaled_y - circle_radius - 5),
                imgproc::FONT_HERSHEY_SIMPLEX,
                font_scale,
                core::Scalar::new(255.0, 0.0, 0.0, 0.0), // è“è‰²
                line_thickness,
                imgproc::LINE_8,
                false,
            )?;
        }
        
        // ğŸ¨ V3: ç»˜åˆ¶ç»†åŒ–æ¥æºæ ‡è®°
        if let (Some(ref tags), Some(ref orig_centers)) = (&self.last_refine_tags, &self.last_original_centers) {
            for i in 0..centers.len().min(tags.len()) {
                let refined_pt = centers.get(i)?;
                let orig_pt = orig_centers.get(i)?;
                let tag = tags[i];
                Self::draw_refine_debug(&mut scaled_image, refined_pt, orig_pt, tag, scale_factor)?;
            }
        }
        
        // æ·»åŠ ç»Ÿè®¡ä¿¡æ¯ï¼ˆæ ¹æ®ç¼©æ”¾è°ƒæ•´ä½ç½®å’Œå¤§å°ï¼‰
        let mut info_text = vec![
            format!("Connected Components Detection (4-conn)"),
            format!("Detected: {}/40 circles", centers.len()),
            format!("Triangle: {:.1}, Hi: {:.1}, Lo: {:.1}", 
                   self.triangle_threshold, self.high_threshold, self.low_threshold),
            format!("Area: {:.0}-{:.0} pxÂ², Shape: AR={:.1}-{:.1}, Fill={:.2}-{:.2}", 
                   self.min_area, self.max_area, self.aspect_ratio_min, self.aspect_ratio_max,
                   self.fill_ratio_min, self.fill_ratio_max),
            format!("Scale: {:.0}% ({}x{})", scale_factor * 100.0, scaled_image.cols(), scaled_image.rows()),
        ];
        
        // ğŸ¨ V3: æ·»åŠ ç»†åŒ–ç»Ÿè®¡ä¿¡æ¯
        if let Some(ref tags) = &self.last_refine_tags {
            let hi_count = tags.iter().filter(|&&t| matches!(t, RefineTag::Hi)).count();
            let lo_count = tags.iter().filter(|&&t| matches!(t, RefineTag::Lo)).count();
            let fb_count = tags.iter().filter(|&&t| matches!(t, RefineTag::Fallback)).count();
            info_text.push(format!("V3 Refine: H={} L={} F={}", hi_count, lo_count, fb_count));
        }
        
        for (i, text) in info_text.iter().enumerate() {
            imgproc::put_text(
                &mut scaled_image,
                text,
                core::Point::new(10, 30 + i as i32 * (25.0 * scale_factor) as i32),
                imgproc::FONT_HERSHEY_SIMPLEX,
                font_scale,
                core::Scalar::new(0.0, 255.0, 255.0, 0.0), // é»„è‰²
                line_thickness,
                imgproc::LINE_8,
                false,
            )?;
        }
        
        // ä¿å­˜å›¾åƒ
        imgcodecs::imwrite(filename, &scaled_image, &core::Vector::<i32>::new())?;
        println!("ğŸ’¾ å·²ä¿å­˜debugå›¾åƒ: {} (ç¼©æ”¾: {:.0}%)", filename, scale_factor * 100.0);
        
        Ok(())
    }
}

/// æµ‹è¯•ä¸»å‡½æ•°
fn main() -> Result<(), Box<dyn std::error::Error>> {
    println!("ğŸš€ å¯åŠ¨è¿é€šåŸŸåœ†ç‚¹æ£€æµ‹æµ‹è¯•ç¨‹åº");
    println!("ğŸ“ æµ‹è¯•ç›®å½•: C:\\Users\\Y000010\\MVS\\Data\\test_0822\\");
    println!("ğŸ¯ æµ‹è¯•èŒƒå›´: l_01.bmp~l_06.bmp, r_01.bmp~r_06.bmp");
    println!("ğŸ” æµ‹è¯•å†…å®¹: è¿é€šåŸŸ+é¢ç§¯è¿‡æ»¤åœ†ç‚¹æ£€æµ‹");
    println!("{}", "=".repeat(60));
    
    let mut detector = ConnectedComponentsDetector::new();
    let mut results = Vec::new();
    
    // æµ‹è¯•æ‰€æœ‰å›¾åƒ
    for i in 1..=6 {
        // æµ‹è¯•å·¦å›¾
        let left_path = format!("C:\\Users\\Y000010\\MVS\\Data\\test_0822\\l_{:02}.bmp", i);
        if Path::new(&left_path).exists() {
            let left_name = format!("l_{:02}", i);
            match test_single_image(&mut detector, &left_path, &left_name) {
                Ok((count, time)) => {
                    results.push((left_name, count, time, true));
                }
                Err(e) => {
                    println!("âŒ æµ‹è¯•å¤±è´¥ {}: {}", left_name, e);
                    results.push((left_name, 0, 0, false));
                }
            }
        }
        
        // æµ‹è¯•å³å›¾
        let right_path = format!("C:\\Users\\Y000010\\MVS\\Data\\test_0822\\r_{:02}.bmp", i);
        if Path::new(&right_path).exists() {
            let right_name = format!("r_{:02}", i);
            match test_single_image(&mut detector, &right_path, &right_name) {
                Ok((count, time)) => {
                    results.push((right_name, count, time, true));
                }
                Err(e) => {
                    println!("âŒ æµ‹è¯•å¤±è´¥ {}: {}", right_name, e);
                    results.push((right_name, 0, 0, false));
                }
            }
        }
    }
    
    // æ‰“å°æµ‹è¯•ç»“æœæ€»ç»“
    print_test_summary(&results);
    
    println!("\nğŸ‰ è¿é€šåŸŸåœ†ç‚¹æ£€æµ‹æµ‹è¯•å®Œæˆ");
    println!("è¯·æŸ¥çœ‹ç”Ÿæˆçš„cc_detection_*.pngæ–‡ä»¶æŸ¥çœ‹æ£€æµ‹æ•ˆæœ");
    
    Ok(())
}

/// æµ‹è¯•å•å¼ å›¾åƒ
fn test_single_image(
    detector: &mut ConnectedComponentsDetector,
    image_path: &str,
    image_name: &str,
) -> Result<(usize, u128), Box<dyn std::error::Error>> {
    println!("\nğŸ” æµ‹è¯•å›¾åƒ: {}", image_name);
    
    // åŠ è½½å›¾åƒ
    let image = imgcodecs::imread(image_path, imgcodecs::IMREAD_GRAYSCALE)?;
    if image.empty() {
        return Err(format!("æ— æ³•åŠ è½½å›¾åƒ: {}", image_path).into());
    }
    
    println!("   å›¾åƒå°ºå¯¸: {}Ã—{}", image.cols(), image.rows());
    
    // æ£€æµ‹åœ†ç‚¹
    let start_time = Instant::now();
    let mut centers = detector.detect_circles(&image)?;
    let detection_time = start_time.elapsed();
    
    // æ’åº
    detector.sort_asymmetric_grid(&mut centers)?;
    
    // ä¿å­˜debugå›¾åƒ
    let debug_filename = format!("cc_detection_{}_count{}.png", image_name, centers.len());
    detector.save_debug_image(&image, &centers, &debug_filename)?;
    
    let count = centers.len();
    let time_ms = detection_time.as_millis();
    
    println!("   âœ… æ£€æµ‹ç»“æœ: {} ä¸ªåœ†ç‚¹, è€—æ—¶: {} ms", count, time_ms);
    
    // è¯„ä¼°ç»“æœ
    if count == 40 {
        println!("   ğŸ¯ å®Œç¾æ£€æµ‹!");
    } else if count >= 35 {
        println!("   âœ… æ£€æµ‹è‰¯å¥½ (â‰¥87.5%)");
    } else if count >= 25 {
        println!("   âš ï¸ æ£€æµ‹ä¸€èˆ¬ (â‰¥62.5%)");
    } else {
        println!("   âŒ æ£€æµ‹ä¸è¶³ (<62.5%)");
    }
    
    Ok((count, time_ms))
}

/// æ‰“å°æµ‹è¯•ç»“æœæ€»ç»“
fn print_test_summary(results: &[(String, usize, u128, bool)]) {
    println!("\nğŸ“Š æµ‹è¯•ç»“æœæ€»ç»“");
    println!("{}", "=".repeat(70));
    println!("å›¾åƒåç§° | æ£€æµ‹æ•°é‡ | è€—æ—¶(ms) | çŠ¶æ€ | è¯„ä¼°");
    println!("{}", "-".repeat(70));
    
    for (name, count, time, success) in results {
        let status = if *success { "âœ…" } else { "âŒ" };
        let evaluation = if *count == 40 {
            "å®Œç¾"
        } else if *count >= 35 {
            "è‰¯å¥½"
        } else if *count >= 25 {
            "ä¸€èˆ¬"
        } else {
            "ä¸è¶³"
        };
        
        println!("{:8} | {:8} | {:8} | {:4} | {}", 
                name, count, time, status, evaluation);
    }
    
    // ç»Ÿè®¡åˆ†æ
    let successful_tests: Vec<_> = results.iter().filter(|(_, _, _, s)| *s).collect();
    if !successful_tests.is_empty() {
        let total_count: usize = successful_tests.iter().map(|(_, c, _, _)| c).sum();
        let total_time: u128 = successful_tests.iter().map(|(_, _, t, _)| t).sum();
        let avg_count = total_count as f64 / successful_tests.len() as f64;
        let avg_time = total_time as f64 / successful_tests.len() as f64;
        
        let perfect_count = successful_tests.iter().filter(|(_, c, _, _)| *c == 40).count();
        let good_count = successful_tests.iter().filter(|(_, c, _, _)| *c >= 35).count();
        
        println!("\nğŸ“ˆ ç»Ÿè®¡åˆ†æ:");
        println!("  æˆåŠŸæµ‹è¯•: {}/{}", successful_tests.len(), results.len());
        println!("  å¹³å‡æ£€æµ‹: {:.1} ä¸ªåœ†ç‚¹", avg_count);
        println!("  å¹³å‡è€—æ—¶: {:.1} ms", avg_time);
        println!("  å®Œç¾æ£€æµ‹: {} ä¸ªå›¾åƒ (40/40)", perfect_count);
        println!("  è‰¯å¥½æ£€æµ‹: {} ä¸ªå›¾åƒ (â‰¥35/40)", good_count);
        
        // æ€§èƒ½è¯„ä¼°
        if avg_time < 50.0 {
            println!("  æ€§èƒ½è¯„ä¼°: âœ… ä¼˜ç§€ (<50ms, ç›®æ ‡è¾¾æˆ!)");
        } else if avg_time < 80.0 {
            println!("  æ€§èƒ½è¯„ä¼°: âš ï¸ è‰¯å¥½ (<80ms, ä¼˜äºSBD)");
        } else {
            println!("  æ€§èƒ½è¯„ä¼°: âŒ éœ€è¦ä¼˜åŒ– (â‰¥80ms)");
        }
        
        // æ£€æµ‹è¯„ä¼°
        if avg_count >= 38.0 {
            println!("  æ£€æµ‹è¯„ä¼°: âœ… è¿é€šåŸŸæ–¹æ³•ä¼˜ç§€");
        } else if avg_count >= 35.0 {
            println!("  æ£€æµ‹è¯„ä¼°: âš ï¸ è¿é€šåŸŸæ–¹æ³•è‰¯å¥½ï¼Œå¯è¿›ä¸€æ­¥ä¼˜åŒ–");
        } else {
            println!("  æ£€æµ‹è¯„ä¼°: âŒ è¿é€šåŸŸæ–¹æ³•éœ€è¦è°ƒæ•´å‚æ•°");
        }
    }
} 