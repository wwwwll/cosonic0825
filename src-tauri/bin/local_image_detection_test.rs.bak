// local_image_detection_test.rs - ä½¿ç”¨æœ¬åœ°å›¾åƒæµ‹è¯•åˆåƒæ£€æµ‹
// ä¸“é—¨ç”¨äºè°ƒè¯•åœ†ç‚¹æ£€æµ‹é—®é¢˜ï¼Œä½¿ç”¨æŒ‡å®šç›®å½•ä¸‹çš„å›¾åƒæ–‡ä»¶

use std::time::Instant;
use std::path::Path;
use opencv::{core, imgcodecs, imgproc, prelude::*};
use merging_image_lib::modules::alignment::AlignmentSystem;

/// æœ¬åœ°å›¾åƒæ£€æµ‹æµ‹è¯•å™¨
pub struct LocalImageDetectionTest {
    alignment_system: Option<AlignmentSystem>,
    test_images_dir: String,
    rectify_maps_path: String,
}

impl LocalImageDetectionTest {
    /// åˆ›å»ºæµ‹è¯•å™¨å®ä¾‹
    pub fn new() -> Result<Self, Box<dyn std::error::Error>> {
        println!("ğŸ”§ åˆå§‹åŒ–æœ¬åœ°å›¾åƒæ£€æµ‹æµ‹è¯•å™¨...");
        
        // è®¾ç½®æµ‹è¯•å›¾åƒç›®å½•
        let test_images_dir = r"C:\Users\Y000010\MVS\Data\test_0819\alignment_test".to_string();
        
        // ç¡®å®šé¡¹ç›®è·¯å¾„
        let exe_path = std::env::current_exe()?;
        let exe_dir = exe_path.parent().unwrap();
        let src_tauri_dir = exe_dir.parent().unwrap().parent().unwrap();
        
        println!("ğŸ“ é¡¹ç›®æ ¹ç›®å½•: {:?}", src_tauri_dir);
        println!("ğŸ“ æµ‹è¯•å›¾åƒç›®å½•: {}", test_images_dir);
        
        // æ„é€ å‚æ•°æ–‡ä»¶è·¯å¾„
        let rectify_maps = src_tauri_dir.join("yaml_last_param_file/rectify_maps.yaml");
        
        // éªŒè¯é‡æ˜ å°„æ–‡ä»¶å­˜åœ¨
        if !rectify_maps.exists() {
            return Err(format!("é‡æ˜ å°„æ–‡ä»¶ä¸å­˜åœ¨: {:?}", rectify_maps).into());
        }
        
        Ok(Self {
            alignment_system: None,
            test_images_dir,
            rectify_maps_path: rectify_maps.to_string_lossy().to_string(),
        })
    }
    
    /// åˆå§‹åŒ–åˆåƒæ£€æµ‹ç³»ç»Ÿ
    fn init_alignment_system(&mut self) -> Result<(), Box<dyn std::error::Error>> {
        if self.alignment_system.is_some() {
            return Ok(());
        }
        
        println!("ğŸš€ åˆå§‹åŒ–åˆåƒæ£€æµ‹ç³»ç»Ÿ...");
        
        let exe_path = std::env::current_exe()?;
        let exe_dir = exe_path.parent().unwrap();
        let src_tauri_dir = exe_dir.parent().unwrap().parent().unwrap();
        
        // ä½¿ç”¨yaml_last_param_fileç›®å½•ä¸‹çš„å‚æ•°æ–‡ä»¶
        let left_cam_params = src_tauri_dir.join("yaml_last_param_file/left_camera_params.yaml");
        let right_cam_params = src_tauri_dir.join("yaml_last_param_file/right_camera_params.yaml");
        let stereo_params = src_tauri_dir.join("yaml_last_param_file/stereo_params.yaml");
        let rectify_params = src_tauri_dir.join("yaml_last_param_file/rectify_params.yaml");
        
        // æ£€æŸ¥æ ‡å®šæ–‡ä»¶æ˜¯å¦å­˜åœ¨
        let required_files = [
            ("å·¦ç›¸æœºå‚æ•°", &left_cam_params),
            ("å³ç›¸æœºå‚æ•°", &right_cam_params),
            ("åŒç›®å‚æ•°", &stereo_params),
            ("æ ¡æ­£å‚æ•°", &rectify_params),
        ];
        
        for (name, path) in &required_files {
            if !path.exists() {
                return Err(format!("{}æ–‡ä»¶ä¸å­˜åœ¨: {:?}", name, path).into());
            }
            println!("   âœ“ {}: {:?}", name, path);
        }
        
        let image_size = core::Size::new(2448, 2048);
        
        // ä½¿ç”¨é¢„åŠ è½½ç‰ˆæœ¬åˆ›å»ºç³»ç»Ÿ
        let alignment_system = AlignmentSystem::new_with_preload(
            image_size,
            left_cam_params.to_str().unwrap(),
            right_cam_params.to_str().unwrap(),
            stereo_params.to_str().unwrap(),
            rectify_params.to_str().unwrap(),
            &self.rectify_maps_path,
        )?;
        
        self.alignment_system = Some(alignment_system);
        println!("âœ“ åˆåƒæ£€æµ‹ç³»ç»Ÿåˆå§‹åŒ–å®Œæˆ");
        
        Ok(())
    }
    
    /// è¿è¡Œæœ¬åœ°å›¾åƒæ£€æµ‹æµ‹è¯•
    pub fn run_tests(&mut self) -> Result<(), Box<dyn std::error::Error>> {
        println!("\nğŸš€ å¼€å§‹æœ¬åœ°å›¾åƒæ£€æµ‹æµ‹è¯•");
        println!("{}", "=".repeat(60));
        
        // åˆå§‹åŒ–ç³»ç»Ÿ
        self.init_alignment_system()?;
        
        // æµ‹è¯•å¤šä¸ªå›¾åƒæ–‡ä»¶
        for i in 1..=15 {
            let filename = format!("calib_left_{:02}.png", i);
            let filepath = format!("{}\\{}", self.test_images_dir, filename);
            
            println!("\nğŸ“· æµ‹è¯•å›¾åƒ {}/{}: {}", i, 15, filename);
            println!("{}", "-".repeat(40));
            
            if !Path::new(&filepath).exists() {
                println!("âš ï¸ æ–‡ä»¶ä¸å­˜åœ¨ï¼Œè·³è¿‡: {}", filepath);
                continue;
            }
            
            // åŠ è½½å›¾åƒ
            let image = imgcodecs::imread(&filepath, imgcodecs::IMREAD_GRAYSCALE)?;
            if image.empty() {
                println!("âŒ æ— æ³•åŠ è½½å›¾åƒ: {}", filepath);
                continue;
            }
            
            println!("âœ“ å›¾åƒåŠ è½½æˆåŠŸ: {}Ã—{}", image.cols(), image.rows());
            
            // æµ‹è¯•åœ†ç‚¹æ£€æµ‹
            self.test_single_image(&image, &filename, i)?;
        }
        
        println!("\nğŸ‰ æœ¬åœ°å›¾åƒæ£€æµ‹æµ‹è¯•å®Œæˆ");
        Ok(())
    }
    
    /// æµ‹è¯•å•å¼ å›¾åƒ
    fn test_single_image(&mut self, image: &core::Mat, filename: &str, index: usize) -> Result<(), Box<dyn std::error::Error>> {
        let alignment_system = self.alignment_system.as_mut().unwrap();
        
        // åˆ›å»ºä¼˜åŒ–çš„SimpleBlobDetector
        let detector = alignment_system.create_optimized_blob_detector()?;
        
        // å‡†å¤‡æ£€æµ‹å‚æ•°
        let pattern_size = core::Size::new(4, 10);  // 10Ã—4 asymmetric circles grid
        let mut corners = core::Vector::<core::Point2f>::new();
        
        println!("ğŸ” æ‰§è¡Œåœ†ç‚¹æ£€æµ‹...");
        let start_time = Instant::now();
        
        // æ‰§è¡Œæ£€æµ‹
        let found = alignment_system.detect_circles_full_image(
            image,
            pattern_size,
            &mut corners,
            &detector,
        )?;
        
        let detection_time = start_time.elapsed();
        println!("â±ï¸ æ£€æµ‹è€—æ—¶: {:.1} ms", detection_time.as_millis());
        
        if found {
            println!("âœ… æ£€æµ‹æˆåŠŸ! æ‰¾åˆ° {} ä¸ªåœ†ç‚¹", corners.len());
            
            // ç”Ÿæˆè°ƒè¯•å›¾åƒ
            //self.save_debug_image(image, &corners, filename, index, true)?;
            
            // åˆ†æåœ†ç‚¹åˆ†å¸ƒ
            self.analyze_corners(&corners)?;
        } else {
            println!("âŒ æ£€æµ‹å¤±è´¥!");
            
            // ä¿å­˜å¤±è´¥çš„è°ƒè¯•å›¾åƒ
            //self.save_debug_image(image, &corners, filename, index, false)?;
            
            // å°è¯•åˆ†æå¤±è´¥åŸå› 
            self.analyze_failure_reason(image)?;
        }
        
        Ok(())
    }
    
    /// ä¿å­˜è°ƒè¯•å›¾åƒ
    fn save_debug_image(
        &self,
        image: &core::Mat,
        corners: &core::Vector<core::Point2f>,
        filename: &str,
        index: usize,
        success: bool,
    ) -> Result<(), Box<dyn std::error::Error>> {
        // è½¬æ¢ä¸ºå½©è‰²å›¾åƒä»¥ä¾¿ç»˜åˆ¶
        let mut debug_image = core::Mat::default();
        if image.channels() == 1 {
            imgproc::cvt_color(
                image,
                &mut debug_image,
                imgproc::COLOR_GRAY2BGR,
                0,
                core::AlgorithmHint::ALGO_HINT_DEFAULT
            )?;
        } else {
            debug_image = image.clone();
        }
        
        // å¦‚æœæ£€æµ‹æˆåŠŸï¼Œç»˜åˆ¶åœ†ç‚¹
        if success && corners.len() > 0 {
            for (i, point) in corners.iter().enumerate() {
                // ç»˜åˆ¶åœ†ç‚¹ï¼ˆçº¢è‰²ï¼‰
                imgproc::circle(
                    &mut debug_image,
                    core::Point::new(point.x as i32, point.y as i32),
                    5,
                    core::Scalar::new(0.0, 0.0, 255.0, 0.0),
                    2,
                    imgproc::LINE_8,
                    0,
                )?;
                
                // æ·»åŠ åºå·ï¼ˆç»¿è‰²ï¼‰
                let text = format!("{}", i);
                imgproc::put_text(
                    &mut debug_image,
                    &text,
                    core::Point::new(point.x as i32 + 10, point.y as i32 - 10),
                    imgproc::FONT_HERSHEY_SIMPLEX,
                    0.4,
                    core::Scalar::new(0.0, 255.0, 0.0, 0.0),
                    1,
                    imgproc::LINE_8,
                    false,
                )?;
            }
        }
        
        // æ·»åŠ çŠ¶æ€æ–‡å­—
        let status_text = if success {
            format!("SUCCESS: {} points", corners.len())
        } else {
            "FAILED: No points detected".to_string()
        };
        
        imgproc::put_text(
            &mut debug_image,
            &status_text,
            core::Point::new(20, 40),
            imgproc::FONT_HERSHEY_SIMPLEX,
            1.0,
            if success {
                core::Scalar::new(0.0, 255.0, 0.0, 0.0)  // ç»¿è‰²
            } else {
                core::Scalar::new(0.0, 0.0, 255.0, 0.0)  // çº¢è‰²
            },
            2,
            imgproc::LINE_8,
            false,
        )?;
        
        // ä¿å­˜è°ƒè¯•å›¾åƒ
        let debug_filename = format!("debug_{:02}_{}_{}.png", 
                                    index,
                                    if success { "SUCCESS" } else { "FAILED" },
                                    filename);
        imgcodecs::imwrite(&debug_filename, &debug_image, &core::Vector::<i32>::new())?;
        println!("ğŸ’¾ å·²ä¿å­˜è°ƒè¯•å›¾åƒ: {}", debug_filename);
        
        Ok(())
    }
    
    /// åˆ†æåœ†ç‚¹åˆ†å¸ƒ
    fn analyze_corners(&self, corners: &core::Vector<core::Point2f>) -> Result<(), Box<dyn std::error::Error>> {
        if corners.len() == 0 {
            return Ok(());
        }
        
        println!("\nğŸ“Š åœ†ç‚¹åˆ†å¸ƒåˆ†æ:");
        
        // è®¡ç®—è¾¹ç•Œ
        let mut min_x = f32::MAX;
        let mut max_x = f32::MIN;
        let mut min_y = f32::MAX;
        let mut max_y = f32::MIN;
        
        for i in 0..corners.len() {
            let point = corners.get(i)?;
            min_x = min_x.min(point.x);
            max_x = max_x.max(point.x);
            min_y = min_y.min(point.y);
            max_y = max_y.max(point.y);
        }
        
        println!("   XèŒƒå›´: [{:.0}, {:.0}] (å®½åº¦: {:.0})", min_x, max_x, max_x - min_x);
        println!("   YèŒƒå›´: [{:.0}, {:.0}] (é«˜åº¦: {:.0})", min_y, max_y, max_y - min_y);
        
        // è¾“å‡ºå‰å‡ ä¸ªç‚¹çš„åæ ‡
        println!("   å‰5ä¸ªç‚¹åæ ‡:");
        for i in 0..std::cmp::min(5, corners.len()) {
            let point = corners.get(i)?;
            println!("     ç‚¹{}: ({:.0}, {:.0})", i, point.x, point.y);
        }
        
        // æ£€æŸ¥ç¬¬0ç‚¹å’Œç¬¬4ç‚¹çš„å…³ç³»ï¼ˆç”¨äºåˆ¤æ–­åˆ—é¡ºåºï¼‰
        if corners.len() >= 5 {
            let p0 = corners.get(0)?;
            let p4 = corners.get(4)?;
            println!("   åˆ—é¡ºåºæ£€æŸ¥: ç‚¹0.x={:.0}, ç‚¹4.x={:.0}", p0.x, p4.x);
            if p0.x < p4.x {
                println!("   âš ï¸ å¯èƒ½éœ€è¦é‡æ–°æ’åºï¼ˆç‚¹0åº”è¯¥åœ¨ç‚¹4å³è¾¹ï¼‰");
            } else {
                println!("   âœ“ åˆ—é¡ºåºæ­£ç¡®");
            }
        }
        
        Ok(())
    }
    
    /// åˆ†ææ£€æµ‹å¤±è´¥åŸå› 
    fn analyze_failure_reason(&self, image: &core::Mat) -> Result<(), Box<dyn std::error::Error>> {
        println!("\nğŸ” å¤±è´¥åŸå› åˆ†æ:");
        
        // åˆ†æå›¾åƒç»Ÿè®¡ä¿¡æ¯
        let mut mean = core::Scalar::default();
        let mut std_dev = core::Scalar::default();
        core::mean_std_dev(image, &mut mean, &mut std_dev, &core::no_array())?;
        
        println!("   å›¾åƒå¹³å‡å€¼: {:.2}", mean[0]);
        println!("   å›¾åƒæ ‡å‡†å·®: {:.2}", std_dev[0]);
        
        if std_dev[0] < 20.0 {
            println!("   âš ï¸ å›¾åƒå¯¹æ¯”åº¦è¿‡ä½ï¼ˆæ ‡å‡†å·® < 20ï¼‰");
        }
        
        if mean[0] < 50.0 {
            println!("   âš ï¸ å›¾åƒè¿‡æš—ï¼ˆå¹³å‡å€¼ < 50ï¼‰");
        } else if mean[0] > 200.0 {
            println!("   âš ï¸ å›¾åƒè¿‡äº®ï¼ˆå¹³å‡å€¼ > 200ï¼‰");
        }
        
        // æ£€æŸ¥å›¾åƒå°ºå¯¸
        if image.cols() != 2448 || image.rows() != 2048 {
            println!("   âš ï¸ å›¾åƒå°ºå¯¸ä¸æ ‡å‡†: {}Ã—{} (æœŸæœ›: 2448Ã—2048)", 
                    image.cols(), image.rows());
        }
        
        println!("\n   å»ºè®®:");
        println!("   1. æ£€æŸ¥æ ‡å®šæ¿æ˜¯å¦å®Œæ•´åœ¨ç”»é¢ä¸­");
        println!("   2. ç¡®ä¿å›¾åƒå¯¹ç„¦æ¸…æ™°");
        println!("   3. è°ƒæ•´å…‰ç…§æ¡ä»¶ï¼Œé¿å…è¿‡æš—æˆ–è¿‡äº®");
        println!("   4. ç¡®ä¿æ˜¯10Ã—4çš„asymmetric circles grid");
        
        Ok(())
    }
}

fn main() -> Result<(), Box<dyn std::error::Error>> {
    println!("ğŸš€ å¯åŠ¨æœ¬åœ°å›¾åƒæ£€æµ‹æµ‹è¯•ç¨‹åº");
    println!("æµ‹è¯•ç›®å½•: C:\\Users\\Y000010\\MVS\\Data\\test_0819\\alignment_test");
    
    let mut test = LocalImageDetectionTest::new()?;
    test.run_tests()?;
    
    println!("\nğŸ‰ æµ‹è¯•ç¨‹åºå®Œæˆ");
    println!("è¯·æ£€æŸ¥ç”Ÿæˆçš„debug_*.pngæ–‡ä»¶ï¼Œåˆ†ææ£€æµ‹ç»“æœ");
    
    Ok(())
} 