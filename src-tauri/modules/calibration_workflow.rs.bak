//! 相机标定工作流程管理模块
//! 
//! 基于现有的calibration_circles.rs算法和camera_workflow.rs相机控制，
//! 提供完整的用户友好标定工作流程。
//! 
//! ## 🎯 核心功能
//! 
//! ### 标定状态检测和管理
//! - 检测现有标定结果，提示标定需求
//! - 验证标定文件完整性和有效性
//! - 标定文件状态管理
//! 
//! ### 标定图像采集工作流
//! - 管理10组双目图像的采集流程
//! - 实时预览和缩略图管理
//! - 图像质量检测和验证
//! 
//! ### 标定算法流程控制
//! - 单目→双目→重映射矩阵的完整标定流程
//! - 进度监控和状态反馈
//! - 基于现有calibration_circles.rs算法
//! 
//! ### 标定结果验证和保存
//! - 重投影误差检查和质量评估
//! - 参数保存和加载管理
//! - 用户指导和错误处理

use std::{
    path::PathBuf,
    fs,
    sync::{Arc, Mutex, atomic::{AtomicBool, Ordering}},
    thread,
    time::{Duration, SystemTime, UNIX_EPOCH},

};

use opencv::{
    core::{Mat, Size, Point2f, Point3f, Vector},
    imgcodecs,
    imgproc,

};

use serde::{Serialize, Deserialize};
use base64::{Engine as _, engine::general_purpose};

use crate::config::SystemConfig;
use crate::modules::{
    calibration_circles::{Calibrator, MonoCalibResult, StereoCalibResult, MonoCamera},
    param_io::*,
    //camera_workflow::CameraWorkflowManager,
};

/// 标定状态枚举
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum CalibrationStatus {
    /// 未标定 - 缺少必要的标定文件
    NotCalibrated,
    /// 部分标定 - 某些标定文件存在但不完整
    PartiallyCalibrated,
    /// 完整标定 - 所有标定文件存在且有效
    FullyCalibrated,
    /// 标定过期 - 标定文件损坏或版本不兼容
    CalibrationExpired,
}

/// 标定文件信息
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CalibrationFiles {
    pub left_camera_params: Option<String>,      // 左相机内参文件路径
    pub right_camera_params: Option<String>,     // 右相机内参文件路径
    pub stereo_params: Option<String>,           // 双目标定参数路径
    pub rectify_params: Option<String>,          // 重映射参数路径
    pub rectify_maps: Option<String>,            // 重映射矩阵路径
}

/// 图像采集阶段
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum CaptureStage {
    /// 空闲状态
    Idle,
    /// 预览模式 - 相机实时预览
    PreviewMode,
    /// 准备拍摄 - 等待用户操作
    ReadyToCapture,
    /// 正在拍摄 - 采集双目图像
    Capturing,
    /// 图像已保存 - 单次采集完成
    ImageSaved,
    /// 采集完成 - 达到目标数量
    CaptureComplete,
}

/// 标定算法阶段
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum CalibrationStage {
    /// 空闲状态
    Idle,
    /// 加载图像和检测特征点
    LoadingImages,
    /// 检测特征点
    DetectingFeatures,
    /// 左相机单目标定
    LeftMonoCalibration,
    /// 右相机单目标定
    RightMonoCalibration,
    /// 双目标定
    StereoCalibration,
    /// 计算重映射矩阵
    ComputingRectification,
    /// 验证标定结果
    ValidatingResults,
    /// 保存参数文件
    SavingParameters,
    /// 标定完成
    Completed,
    /// 标定错误
    Error(String),
}

/// 图像对信息
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ImagePair {
    pub pair_id: u32,
    pub left_image_path: String,
    pub right_image_path: String,
    pub thumbnail_left: String,       // Base64缩略图
    pub thumbnail_right: String,      // Base64缩略图
    pub capture_timestamp: String,
    pub is_valid: bool,               // 是否检测到标定板
    pub feature_count: u32,           // 检测到的特征点数量
}

/// 采集会话信息
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CaptureSession {
    pub session_id: String,           // 会话ID
    pub target_image_count: u32,      // 目标图像数量（默认10）
    pub captured_images: Vec<ImagePair>,
    pub current_stage: CaptureStage,
    pub capture_config: CaptureConfig,
    pub created_at: String,
}

/// 采集配置
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CaptureConfig {
    pub preview_fps: u32,             // 预览帧率
    pub capture_resolution: (u32, u32), // 采集分辨率
    pub thumbnail_size: (u32, u32),   // 缩略图尺寸
    pub save_directory: String,       // 图像保存目录
    pub image_format: String,         // 图像格式 (png/jpg)
}

/// 标定进度信息
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CalibrationProgress {
    pub current_stage: CalibrationStage,
    pub progress_percentage: f32,      // 0-100
    pub stage_description: String,     // 当前阶段描述
    pub estimated_remaining_time: u32, // 预估剩余时间（秒）
    pub processed_images: u32,         // 已处理图像数量
    pub total_images: u32,             // 总图像数量
}

/// 相机质量评估
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CameraQuality {
    pub rms_error: f64,               // RMS重投影误差
    pub max_error: f64,               // 最大重投影误差
    pub mean_error: f64,              // 平均重投影误差
    pub coverage_score: f32,          // 标定板覆盖度评分 (0-100)
    pub angle_diversity: f32,         // 角度多样性评分 (0-100)
}

/// 双目质量评估
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct StereoQuality {
    pub stereo_rms_error: f64,        // 双目标定RMS误差
    pub epipolar_error: f64,          // 极线约束误差
    pub baseline_accuracy: f64,       // 基线精度
}

/// 质量等级
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum QualityGrade {
    Excellent,  // 优秀 (RMS < 0.5)
    Good,       // 良好 (RMS < 1.0)
    Acceptable, // 可接受 (RMS < 2.0)
    Poor,       // 较差 (RMS >= 2.0)
}

/// 标定质量评估
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CalibrationQuality {
    pub overall_grade: QualityGrade,   // 总体评级
    pub left_camera_quality: CameraQuality,
    pub right_camera_quality: CameraQuality,
    pub stereo_quality: StereoQuality,
    pub recommendations: Vec<String>,   // 改进建议
}

/// 标定结果
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CalibrationResult {
    pub success: bool,
    pub left_rms_error: f64,           // 左相机重投影误差
    pub right_rms_error: f64,          // 右相机重投影误差
    pub stereo_rms_error: f64,         // 双目标定误差
    pub error_threshold: f64,          // 错误阈值
    pub error_message: Option<String>, // 错误信息
    pub saved_files: CalibrationFiles, // 保存的文件路径
    pub quality: Option<CalibrationQuality>, // 质量评估
    pub calibration_time: String,      // 标定完成时间
}

/// 标定错误类型
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum CalibrationError {
    InsufficientImages,      // 图像数量不足
    FeatureDetectionFailed,  // 特征点检测失败
    CalibrationFailed,       // 标定算法失败
    HighReprojectionError,   // 重投影误差过大
    FileSystemError,         // 文件系统错误
    ConfigurationError,      // 配置错误
    CameraError,             // 相机操作错误
}

/// 用户指导信息
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UserGuidance {
    pub title: String,
    pub message: String,
    pub actions: Vec<String>,
    pub can_retry: bool,
}

/// 标定工作流程管理器
pub struct CalibrationWorkflow {
    system_config: SystemConfig,
    current_status: CalibrationStatus,
    calibration_files: CalibrationFiles,
    
    // 图像采集相关
    capture_session: Option<CaptureSession>,
    //camera_workflow: Option<CameraWorkflowManager>,
    
    // 标定算法相关
    calibrator: Option<Calibrator>,
    calibration_progress: Arc<Mutex<CalibrationProgress>>,
    calibration_running: Arc<AtomicBool>,
    
    // 结果存储
    last_calibration_result: Option<CalibrationResult>,
}

impl CalibrationWorkflow {
    /// 创建新的标定工作流程管理器
    pub fn new(system_config: SystemConfig) -> Result<Self, String> {
        println!("🏗️ 初始化标定工作流程管理器...");
        
        let calibration_files = CalibrationFiles {
            left_camera_params: Some(system_config.file_paths.left_camera_params_path.clone()),
            right_camera_params: Some(system_config.file_paths.right_camera_params_path.clone()),
            stereo_params: Some(system_config.file_paths.stereo_params_path.clone()),
            rectify_params: Some(system_config.file_paths.rectify_params_path.clone()),
            rectify_maps: Some(system_config.file_paths.rectify_maps_path.clone()),
        };
        
        let initial_progress = CalibrationProgress {
            current_stage: CalibrationStage::Idle,
            progress_percentage: 0.0,
            stage_description: "等待开始标定".to_string(),
            estimated_remaining_time: 0,
            processed_images: 0,
            total_images: 0,
        };
        
        let mut workflow = Self {
            current_status: CalibrationStatus::NotCalibrated,
            calibration_files,
            system_config,
            capture_session: None,
            //camera_workflow: None,
            calibrator: None,
            calibration_progress: Arc::new(Mutex::new(initial_progress)),
            calibration_running: Arc::new(AtomicBool::new(false)),
            last_calibration_result: None,
        };
        
        // 检测当前标定状态
        workflow.detect_calibration_status()?;
        
        println!("✅ 标定工作流程管理器初始化完成");
        Ok(workflow)
    }
    
    /// 检测当前标定状态
    pub fn detect_calibration_status(&mut self) -> Result<CalibrationStatus, String> {
        println!("🔍 检测标定状态...");
        
        let mut existing_files = 0;
        let mut valid_files = 0;
        
        // 检查左相机参数
        if let Some(path) = &self.calibration_files.left_camera_params {
            if PathBuf::from(path).exists() {
                existing_files += 1;
                if self.validate_camera_params_file(path).is_ok() {
                    valid_files += 1;
                }
            }
        }
        
        // 检查右相机参数
        if let Some(path) = &self.calibration_files.right_camera_params {
            if PathBuf::from(path).exists() {
                existing_files += 1;
                if self.validate_camera_params_file(path).is_ok() {
                    valid_files += 1;
                }
            }
        }
        
        // 检查双目参数
        if let Some(path) = &self.calibration_files.stereo_params {
            if PathBuf::from(path).exists() {
                existing_files += 1;
                if self.validate_stereo_params_file(path).is_ok() {
                    valid_files += 1;
                }
            }
        }
        
        // 检查重映射参数
        if let Some(path) = &self.calibration_files.rectify_params {
            if PathBuf::from(path).exists() {
                existing_files += 1;
                if self.validate_rectify_params_file(path).is_ok() {
                    valid_files += 1;
                }
            }
        }
        
        // 确定标定状态
        let status = match (existing_files, valid_files) {
            (0, 0) => CalibrationStatus::NotCalibrated,
            (n, v) if n == v && n >= 4 => CalibrationStatus::FullyCalibrated,
            (n, v) if n > 0 && v < n => CalibrationStatus::CalibrationExpired,
            _ => CalibrationStatus::PartiallyCalibrated,
        };
        
        self.current_status = status.clone();
        
        println!("📊 标定状态检测完成: {:?} (存在文件: {}, 有效文件: {})", 
                status, existing_files, valid_files);
        
        Ok(status)
    }
    
    /// 验证相机参数文件
    fn validate_camera_params_file(&self, path: &str) -> Result<(), String> {
        load_camera_params(path)
            .map_err(|e| format!("相机参数文件无效: {}", e))?;
        Ok(())
    }
    
    /// 验证双目参数文件
    fn validate_stereo_params_file(&self, path: &str) -> Result<(), String> {
        load_stereo_params(path)
            .map_err(|e| format!("双目参数文件无效: {}", e))?;
        Ok(())
    }
    
    /// 验证重映射参数文件
    fn validate_rectify_params_file(&self, path: &str) -> Result<(), String> {
        load_rectify_params(path)
            .map_err(|e| format!("重映射参数文件无效: {}", e))?;
        Ok(())
    }
    
    /// 获取当前标定状态
    pub fn get_calibration_status(&self) -> CalibrationStatus {
        self.current_status.clone()
    }
    
    /// 获取标定文件信息
    pub fn get_calibration_files_info(&self) -> CalibrationFiles {
        self.calibration_files.clone()
    }
    
    /// 开始标定图像采集会话
    pub fn start_calibration_capture(&mut self) -> Result<String, String> {
        println!("🎬 开始标定图像采集会话...");
        
        // 创建采集会话ID
        let session_id = format!("calibration_{}", 
            SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs());
        
        // 创建保存目录
        let save_directory = format!("calibration_images/{}", session_id);
        fs::create_dir_all(&save_directory)
            .map_err(|e| format!("创建保存目录失败: {}", e))?;
        
        // 创建采集配置
        let capture_config = CaptureConfig {
            preview_fps: 10,
            capture_resolution: (2448, 2048),
            thumbnail_size: (200, 166),
            save_directory: save_directory.clone(),
            image_format: "png".to_string(),
        };
        
        // 创建采集会话
        let capture_session = CaptureSession {
            session_id: session_id.clone(),
            target_image_count: 10,
            captured_images: Vec::new(),
            current_stage: CaptureStage::Idle,
            capture_config,
            created_at: chrono::Utc::now().to_rfc3339(),
        };
        
        self.capture_session = Some(capture_session);
        
        // 初始化相机工作流程
        // 注释掉因为camera_workflow模块没有实现
        // if self.camera_workflow.is_none() {
        //     self.camera_workflow = Some(CameraWorkflowManager::new()
        //         .map_err(|e| format!("相机初始化失败: {:?}", e))?);
        // }
        
        // 切换到预览模式
        // if let Some(camera) = &mut self.camera_workflow {
        //     camera.switch_stage(crate::camera_ffi::Stage::Preview)
        //         .map_err(|e| format!("切换到预览模式失败: {:?}", e))?;
        // }
        
        // 更新会话状态
        if let Some(session) = &mut self.capture_session {
            session.current_stage = CaptureStage::PreviewMode;
        }
        
        println!("✅ 标定图像采集会话已启动: {}", session_id);
        Ok(session_id)
    }
    
    /// 拍摄一组双目标定图像
    pub fn capture_calibration_image(&mut self) -> Result<String, String> {
        println!("📸 拍摄标定图像对...");
        
        let session = self.capture_session.as_mut()
            .ok_or("没有活动的采集会话")?;
        
        if session.current_stage != CaptureStage::PreviewMode && 
           session.current_stage != CaptureStage::ReadyToCapture {
            return Err("当前状态不允许拍摄".to_string());
        }
        
        // 更新状态
        session.current_stage = CaptureStage::Capturing;
        
        // 获取相机工作流程
        // let camera = self.camera_workflow.as_mut()
        //     .ok_or("相机工作流程未初始化")?;
        
        // 切换到检测模式进行高质量采集
        // camera.switch_stage(crate::camera_ffi::Stage::Detection)
        //     .map_err(|e| format!("切换到检测模式失败: {:?}", e))?;
        
        // 等待相机稳定
        thread::sleep(Duration::from_millis(500));
        
        // 执行双目同步采集
        let pair_id = session.captured_images.len() as u32;
        let timestamp = chrono::Utc::now().to_rfc3339();
        
        let left_image_path = format!("{}/left_{:02}.png", 
            session.capture_config.save_directory, pair_id);
        let right_image_path = format!("{}/right_{:02}.png", 
            session.capture_config.save_directory, pair_id);
        
        // 执行双目相机采集
        // TODO: 迁移到使用CameraManager统一接口
        return Err("图像采集功能需要重构以使用CameraManager接口".to_string());
        
        // 切换回预览模式
        // camera.switch_stage(crate::camera_ffi::Stage::Preview)
        //     .map_err(|e| format!("切换回预览模式失败: {:?}", e))?;
        
        // // 获取缩略图尺寸（避免借用冲突）
        // let thumbnail_size = session.capture_config.thumbnail_size;
        
        // // 释放所有可变借用
        // drop(session);
        // drop(camera);
        
        // 检测标定板特征点
        let (is_valid, feature_count) = self.validate_calibration_image_pair(
            &left_image_path, &right_image_path)?;
        
        // 生成缩略图
        // let thumbnail_left = self.generate_thumbnail(&left_image_path, thumbnail_size)?;
        // let thumbnail_right = self.generate_thumbnail(&right_image_path, thumbnail_size)?;
        
        // 创建图像对信息
        // let image_pair = ImagePair {
        //     pair_id,
        //     left_image_path,
        //     right_image_path,
        //     //thumbnail_left,
        //     //thumbnail_right,
        //     capture_timestamp: timestamp,
        //     is_valid,
        //     feature_count,
        // };
        
        // 重新获取session的可变引用来保存结果
        let session = self.capture_session.as_mut().unwrap();
        
        // 保存到会话中
        //session.captured_images.push(image_pair.clone());
        
        // 更新会话状态
        if session.captured_images.len() >= session.target_image_count as usize {
            session.current_stage = CaptureStage::CaptureComplete;
        } else {
            session.current_stage = CaptureStage::ReadyToCapture;
        }
        
        println!("✅ 标定图像对采集完成: {} (有效: {}, 特征点: {})", 
                pair_id, is_valid, feature_count);
        
        Ok("由于camera_manager.rs重构测试,暂时跳过该函数".to_string())
    }
    

    
    /// 模拟双目采集的后备方案 (仅用于测试)
    fn simulate_dual_camera_capture_fallback(&self, left_path: &str, right_path: &str) -> Result<(), String> {
        // TODO: 当camera_workflow集成完成后，可以移除此函数
        // 这里创建空白图像作为占位符
        let image = Mat::zeros(2048, 2448, opencv::core::CV_8UC3)
            .map_err(|e| format!("创建图像失败: {}", e))?;
        
        imgcodecs::imwrite(left_path, &image, &Vector::new())
            .map_err(|e| format!("保存左图像失败: {}", e))?;
        
        imgcodecs::imwrite(right_path, &image, &Vector::new())
            .map_err(|e| format!("保存右图像失败: {}", e))?;
        
        println!("📷 模拟双目图像采集完成（后备方案）: {} | {}", left_path, right_path);
        Ok(())
    }
    
    /// 验证标定图像对
    fn validate_calibration_image_pair(&self, left_path: &str, right_path: &str) -> Result<(bool, u32), String> {
        // 1. 验证图像文件是否存在和有效
        let files_valid = crate::modules::param_io::validate_stereo_image_pair(left_path, right_path)
            .map_err(|e| format!("验证图像文件失败: {}", e))?;
        
        if !files_valid {
            return Ok((false, 0));
        }
        
        // 2. TODO: 使用calibration_circles.rs检测特征点
        // 实际实现时的逻辑：
        // let left_image = opencv::imgcodecs::imread(left_path, opencv::imgcodecs::IMREAD_COLOR)?;
        // let right_image = opencv::imgcodecs::imread(right_path, opencv::imgcodecs::IMREAD_COLOR)?;
        // let (left_corners, left_ids) = calibrator.detect_corners(&left_image)?;
        // let (right_corners, right_ids) = calibrator.detect_corners(&right_image)?;
        // let feature_count = left_corners.len().min(right_corners.len()) as u32;
        
        // 当前返回模拟结果
        Ok((true, 40)) // 假设检测到40个特征点
    }
    
    /// 生成缩略图
    fn generate_thumbnail(&self, image_path: &str, size: (u32, u32)) -> Result<String, String> {
        let image = imgcodecs::imread(image_path, imgcodecs::IMREAD_COLOR)
            .map_err(|e| format!("读取图像失败: {}", e))?;
        
        let mut thumbnail = Mat::default();
        imgproc::resize(&image, &mut thumbnail, 
            opencv::core::Size::new(size.0 as i32, size.1 as i32),
            0.0, 0.0, imgproc::INTER_LINEAR)
            .map_err(|e| format!("缩放图像失败: {}", e))?;
        
        // 编码为PNG
        let mut buffer = Vector::new();
        imgcodecs::imencode(".png", &thumbnail, &mut buffer, &Vector::new())
            .map_err(|e| format!("编码图像失败: {}", e))?;
        
        // 转换为Base64
        let base64_str = general_purpose::STANDARD.encode(buffer.as_slice());
        Ok(format!("data:image/png;base64,{}", base64_str))
    }
    
    /// 获取已采集的图像列表
    pub fn get_captured_images(&self) -> Result<Vec<ImagePair>, String> {
        let session = self.capture_session.as_ref()
            .ok_or("没有活动的采集会话")?;
        
        Ok(session.captured_images.clone())
    }
    
    /// 删除指定的图像对
    pub fn delete_captured_image(&mut self, pair_id: u32) -> Result<(), String> {
        let session = self.capture_session.as_mut()
            .ok_or("没有活动的采集会话")?;
        
        // 找到并删除图像对
        let index = session.captured_images.iter()
            .position(|img| img.pair_id == pair_id)
            .ok_or("找不到指定的图像对")?;
        
        let image_pair = session.captured_images.remove(index);
        
        // 删除文件
        let _ = fs::remove_file(&image_pair.left_image_path);
        let _ = fs::remove_file(&image_pair.right_image_path);
        
        // 更新会话状态
        if session.captured_images.len() < session.target_image_count as usize {
            session.current_stage = CaptureStage::ReadyToCapture;
        }
        
        println!("🗑️ 已删除图像对: {}", pair_id);
        Ok(())
    }
    
    /// 完成图像采集
    pub fn finish_image_capture(&mut self) -> Result<bool, String> {
        let session = self.capture_session.as_ref()
            .ok_or("没有活动的采集会话")?;
        
        // 检查是否满足标定要求
        let valid_images = session.captured_images.iter()
            .filter(|img| img.is_valid)
            .count();
        
        if valid_images < 8 {
            return Ok(false); // 至少需要8组有效图像
        }
        
        println!("✅ 图像采集完成，有效图像: {}/{}", valid_images, session.captured_images.len());
        
        // 注意：这里不释放相机资源，只是完成图像采集阶段
        // 相机将继续用于后续的标定过程或其他工作流程
        
        Ok(true)
    }
    
    /// 完成整个标定工作流程并释放资源
    pub fn finish_calibration_workflow(&mut self) -> Result<(), String> {
        println!("🎯 标定工作流程完成，释放相机资源...");
        
        // // 释放相机工作流程资源
        // if let Some(mut camera_workflow) = self.camera_workflow.take() {
        //     camera_workflow.release().map_err(|e| format!("释放相机资源失败: {:?}", e))?;
        //     println!("📷 相机资源已释放");
        // }
        
        // 清理标定会话
        self.capture_session = None;
        self.last_calibration_result = None;
        
        // 停止标定流程
        if self.calibration_running.load(Ordering::Relaxed) {
            self.calibration_running.store(false, Ordering::Relaxed);
        }
        
        println!("✅ 标定工作流程资源清理完成");
        Ok(())
    }
    
    /// 获取当前标定进度
    pub fn get_calibration_progress(&self) -> CalibrationProgress {
        self.calibration_progress.lock().unwrap().clone()
    }
    
    /// 获取最后的标定结果
    pub fn get_calibration_result(&self) -> Option<CalibrationResult> {
        self.last_calibration_result.clone()
    }
    
    /// 开始标定计算流程
    pub fn start_calibration_process(&mut self) -> Result<(), String> {
        println!("🚀 开始标定计算流程...");
        
        // 检查是否有足够的图像
        let session = self.capture_session.as_ref()
            .ok_or("没有活动的采集会话")?;
        
        let valid_images: Vec<_> = session.captured_images.iter()
            .filter(|img| img.is_valid)
            .collect();
        
        if valid_images.len() < 8 {
            return Err(format!("有效图像数量不足: {}/8", valid_images.len()));
        }
        
        // 设置标定运行状态
        self.calibration_running.store(true, Ordering::SeqCst);
        
        // 初始化标定器
        let (diameter, center_distance, pattern_size) = self.system_config.get_effective_pattern_params();
        let image_size = Size::new(
            session.capture_config.capture_resolution.0 as i32,
            session.capture_config.capture_resolution.1 as i32
        );
        
        self.calibrator = Some(Calibrator::new(
            image_size,
            diameter,
            center_distance,
            pattern_size,
            2.0, // 重投影误差阈值
        ).map_err(|e| format!("创建标定器失败: {}", e))?);
        
        // 在后台线程中运行标定流程
        let captured_images = session.captured_images.clone();
        let progress_arc = self.calibration_progress.clone();
        let running_arc = self.calibration_running.clone();
        let system_config = self.system_config.clone();
        
        thread::spawn(move || {
            let result = Self::run_calibration_background(
                captured_images,
                system_config,
                progress_arc.clone(),
                running_arc.clone(),
            );
            
            match result {
                Ok(_calibration_result) => {
                    println!("✅ 标定流程完成成功");
                    // TODO: 保存结果到主线程
                }
                Err(e) => {
                    println!("❌ 标定流程失败: {}", e);
                    let mut progress = progress_arc.lock().unwrap();
                    progress.current_stage = CalibrationStage::Error(e);
                }
            }
            
            running_arc.store(false, Ordering::SeqCst);
        });
        
        println!("✅ 标定计算流程已启动");
        Ok(())
    }
    
    /// 后台运行标定流程
    fn run_calibration_background(
        captured_images: Vec<ImagePair>,
        system_config: SystemConfig,
        progress_arc: Arc<Mutex<CalibrationProgress>>,
        running_arc: Arc<AtomicBool>,
    ) -> Result<CalibrationResult, String> {
        
        // 阶段1: 加载图像和检测特征点
        {
            let mut progress = progress_arc.lock().unwrap();
            progress.current_stage = CalibrationStage::LoadingImages;
            progress.progress_percentage = 10.0;
            progress.stage_description = "正在加载标定图像...".to_string();
            progress.estimated_remaining_time = 45;
            progress.total_images = captured_images.len() as u32;
        }
        
        let valid_images: Vec<_> = captured_images.iter()
            .filter(|img| img.is_valid)
            .collect();
        
        // 重新创建标定器
        let (diameter, center_distance, pattern_size) = system_config.get_effective_pattern_params();
        let image_size = Size::new(2448, 2048); // 使用默认分辨率
        
        let mut calibrator = Calibrator::new(
            image_size,
            diameter,
            center_distance,
            pattern_size,
            2.0, // 重投影误差阈值
        ).map_err(|e| format!("创建标定器失败: {}", e))?;
        
        let (left_obj_points, left_img_points, right_obj_points, right_img_points) = 
            Self::load_and_detect_features(&mut calibrator, &valid_images, &progress_arc)?;
        
        if !running_arc.load(Ordering::SeqCst) {
            return Err("标定流程被取消".to_string());
        }
        
        // 阶段2: 左相机单目标定
        {
            let mut progress = progress_arc.lock().unwrap();
            progress.current_stage = CalibrationStage::LeftMonoCalibration;
            progress.progress_percentage = 30.0;
            progress.stage_description = "正在进行左相机标定...".to_string();
            progress.estimated_remaining_time = 35;
        }
        
        let left_result = calibrator.calibrate_mono(&left_obj_points, &left_img_points)
            .map_err(|e| format!("左相机标定失败: {}", e))?;
        
        let (left_camera_matrix, left_dist_coeffs, left_rms_error) = match left_result {
            MonoCalibResult::Success { camera_matrix, dist_coeffs, error } => {
                (camera_matrix, dist_coeffs, error)
            }
            MonoCalibResult::NeedRecalibration(error) => {
                return Err(format!("左相机标定精度不足: RMS = {:.3}", error));
            }
        };
        
        if !running_arc.load(Ordering::SeqCst) {
            return Err("标定流程被取消".to_string());
        }
        
        // 阶段3: 右相机单目标定
        {
            let mut progress = progress_arc.lock().unwrap();
            progress.current_stage = CalibrationStage::RightMonoCalibration;
            progress.progress_percentage = 50.0;
            progress.stage_description = "正在进行右相机标定...".to_string();
            progress.estimated_remaining_time = 25;
        }
        
        let right_result = calibrator.calibrate_mono(&right_obj_points, &right_img_points)
            .map_err(|e| format!("右相机标定失败: {}", e))?;
        
        let (right_camera_matrix, right_dist_coeffs, right_rms_error) = match right_result {
            MonoCalibResult::Success { camera_matrix, dist_coeffs, error } => {
                (camera_matrix, dist_coeffs, error)
            }
            MonoCalibResult::NeedRecalibration(error) => {
                return Err(format!("右相机标定精度不足: RMS = {:.3}", error));
            }
        };
        
        if !running_arc.load(Ordering::SeqCst) {
            return Err("标定流程被取消".to_string());
        }
        
        // 阶段4: 双目标定
        {
            let mut progress = progress_arc.lock().unwrap();
            progress.current_stage = CalibrationStage::StereoCalibration;
            progress.progress_percentage = 70.0;
            progress.stage_description = "正在进行双目标定...".to_string();
            progress.estimated_remaining_time = 15;
        }
        
        let left_mono = MonoCamera { 
            camera_matrix: left_camera_matrix.clone(), 
            dist_coeffs: left_dist_coeffs.clone() 
        };
        let right_mono = MonoCamera { 
            camera_matrix: right_camera_matrix.clone(), 
            dist_coeffs: right_dist_coeffs.clone() 
        };
        
        let stereo_result = calibrator.calibrate_stereo(
            &left_obj_points,
            &left_img_points,
            &right_img_points,
            &left_mono,
            &right_mono,
        ).map_err(|e| format!("双目标定失败: {}", e))?;
        
        let (r_matrix, t_vector, stereo_rms_error) = match stereo_result {
            StereoCalibResult::Success { r, t, error } => (r, t, error),
            StereoCalibResult::NeedRecalibration(error) => {
                return Err(format!("双目标定精度不足: RMS = {:.3}", error));
            }
        };
        
        if !running_arc.load(Ordering::SeqCst) {
            return Err("标定流程被取消".to_string());
        }
        
        // 阶段5: 计算重映射矩阵
        {
            let mut progress = progress_arc.lock().unwrap();
            progress.current_stage = CalibrationStage::ComputingRectification;
            progress.progress_percentage = 85.0;
            progress.stage_description = "正在计算重映射矩阵...".to_string();
            progress.estimated_remaining_time = 8;
        }
        
        let rectify_maps = calibrator.compute_stereo_rectify(
            &left_mono,
            &right_mono,
            &r_matrix,
            &t_vector,
        ).map_err(|e| format!("计算重映射矩阵失败: {}", e))?;
        
        let (left_map1, left_map2) = calibrator.compute_undistort_maps(
            &left_camera_matrix,
            &left_dist_coeffs,
            &rectify_maps.r1,
            &rectify_maps.p1,
        ).map_err(|e| format!("计算左相机重映射失败: {}", e))?;
        
        let (right_map1, right_map2) = calibrator.compute_undistort_maps(
            &right_camera_matrix,
            &right_dist_coeffs,
            &rectify_maps.r2,
            &rectify_maps.p2,
        ).map_err(|e| format!("计算右相机重映射失败: {}", e))?;
        
        if !running_arc.load(Ordering::SeqCst) {
            return Err("标定流程被取消".to_string());
        }
        
        // 阶段6: 验证和保存结果
        {
            let mut progress = progress_arc.lock().unwrap();
            progress.current_stage = CalibrationStage::ValidatingResults;
            progress.progress_percentage = 95.0;
            progress.stage_description = "正在验证标定结果...".to_string();
            progress.estimated_remaining_time = 3;
        }
        
        let quality = Self::assess_calibration_quality(
            left_rms_error, right_rms_error, stereo_rms_error, valid_images.len()
        );
        
        // 保存标定参数
        {
            let mut progress = progress_arc.lock().unwrap();
            progress.current_stage = CalibrationStage::SavingParameters;
            progress.progress_percentage = 98.0;
            progress.stage_description = "正在保存标定参数...".to_string();
            progress.estimated_remaining_time = 1;
        }
        
        let saved_files = Self::save_calibration_parameters(
            &system_config,
            &left_camera_matrix, &left_dist_coeffs,
            &right_camera_matrix, &right_dist_coeffs,
            &r_matrix, &t_vector,
            &rectify_maps,
            &left_map1, &left_map2,
            &right_map1, &right_map2,
        )?;
        
        // 标定完成
        {
            let mut progress = progress_arc.lock().unwrap();
            progress.current_stage = CalibrationStage::Completed;
            progress.progress_percentage = 100.0;
            progress.stage_description = "标定完成！".to_string();
            progress.estimated_remaining_time = 0;
        }
        
        let result = CalibrationResult {
            success: true,
            left_rms_error,
            right_rms_error,
            stereo_rms_error,
            error_threshold: 2.0,
            error_message: None,
            saved_files,
            quality: Some(quality),
            calibration_time: chrono::Utc::now().to_rfc3339(),
        };
        
        Ok(result)
    }
    
    /// 加载图像并检测特征点
    fn load_and_detect_features(
        calibrator: &mut Calibrator,
        images: &[&ImagePair],
        progress_arc: &Arc<Mutex<CalibrationProgress>>,
    ) -> Result<(Vector<Vector<Point3f>>, Vector<Vector<Point2f>>, 
                Vector<Vector<Point3f>>, Vector<Vector<Point2f>>), String> {
        
        let mut left_obj_points = Vector::new();
        let mut left_img_points = Vector::new();
        let mut right_obj_points = Vector::new();
        let mut right_img_points = Vector::new();
        
        for (i, image_pair) in images.iter().enumerate() {
            {
                let mut progress = progress_arc.lock().unwrap();
                progress.current_stage = CalibrationStage::DetectingFeatures;
                progress.progress_percentage = 10.0 + (i as f32 / images.len() as f32) * 15.0;
                progress.stage_description = format!("正在检测第 {}/{} 组图像特征点...", i + 1, images.len());
                progress.processed_images = i as u32;
            }
            
            // 加载左图像
            let left_image = imgcodecs::imread(&image_pair.left_image_path, imgcodecs::IMREAD_GRAYSCALE)
                .map_err(|e| format!("加载左图像失败 {}: {}", image_pair.left_image_path, e))?;
            
            // 加载右图像
            let right_image = imgcodecs::imread(&image_pair.right_image_path, imgcodecs::IMREAD_GRAYSCALE)
                .map_err(|e| format!("加载右图像失败 {}: {}", image_pair.right_image_path, e))?;
            
            // 检测左图像特征点
            let left_corners = calibrator.find_asymmetric_circles_grid_points(&left_image, false)
                .map_err(|e| format!("左图像特征点检测失败: {}", e))?;
            
            // 检测右图像特征点
            let right_corners = calibrator.find_asymmetric_circles_grid_points(&right_image, false)
                .map_err(|e| format!("右图像特征点检测失败: {}", e))?;
            
            if left_corners.len() > 0 && right_corners.len() > 0 {
                // 生成世界坐标点
                let obj_points = calibrator.generate_world_points_from_list()
                    .map_err(|e| format!("生成世界坐标失败: {}", e))?;
                
                left_obj_points.push(obj_points.clone());
                left_img_points.push(left_corners);
                right_obj_points.push(obj_points);
                right_img_points.push(right_corners);
            }
        }
        
        if left_img_points.len() < 8 {
            return Err(format!("检测到的有效特征点组数不足: {}/8", left_img_points.len()));
        }
        
        println!("✅ 特征点检测完成，有效组数: {}", left_img_points.len());
        Ok((left_obj_points, left_img_points, right_obj_points, right_img_points))
    }
    
    /// 评估标定质量
    fn assess_calibration_quality(
        left_rms: f64,
        right_rms: f64,
        stereo_rms: f64,
        image_count: usize,
    ) -> CalibrationQuality {
        
        // 评估总体等级
        let max_rms = left_rms.max(right_rms).max(stereo_rms);
        let overall_grade = match max_rms {
            x if x < 0.5 => QualityGrade::Excellent,
            x if x < 1.0 => QualityGrade::Good,
            x if x < 2.0 => QualityGrade::Acceptable,
            _ => QualityGrade::Poor,
        };
        
        // 生成改进建议
        let mut recommendations = Vec::new();
        
        if max_rms > 1.0 {
            recommendations.push("重投影误差较大，建议重新采集标定图像".to_string());
        }
        
        if image_count < 12 {
            recommendations.push("建议增加更多标定图像以提高精度".to_string());
        }
        
        if left_rms > 1.5 || right_rms > 1.5 {
            recommendations.push("建议确保标定板在图像中清晰可见，避免模糊和遮挡".to_string());
        }
        
        if stereo_rms > 1.5 {
            recommendations.push("双目标定误差较大，建议检查左右相机同步性".to_string());
        }
        
        if overall_grade == QualityGrade::Excellent {
            recommendations.push("标定质量优秀，可以投入使用".to_string());
        }
        
        CalibrationQuality {
            overall_grade,
            left_camera_quality: CameraQuality {
                rms_error: left_rms,
                max_error: left_rms * 1.5,
                mean_error: left_rms * 0.8,
                coverage_score: 85.0, // 简化评估
                angle_diversity: 80.0,
            },
            right_camera_quality: CameraQuality {
                rms_error: right_rms,
                max_error: right_rms * 1.5,
                mean_error: right_rms * 0.8,
                coverage_score: 85.0,
                angle_diversity: 80.0,
            },
            stereo_quality: StereoQuality {
                stereo_rms_error: stereo_rms,
                epipolar_error: stereo_rms * 0.9,
                baseline_accuracy: 95.0,
            },
            recommendations,
        }
    }
    
    /// 保存标定参数到文件
    fn save_calibration_parameters(
        system_config: &SystemConfig,
        left_camera_matrix: &Mat, left_dist_coeffs: &Mat,
        right_camera_matrix: &Mat, right_dist_coeffs: &Mat,
        r_matrix: &Mat, t_vector: &Mat,
        rectify_maps: &crate::modules::calibration_circles::RectifyMaps,
        left_map1: &Mat, left_map2: &Mat,
        right_map1: &Mat, right_map2: &Mat,
    ) -> Result<CalibrationFiles, String> {
        
        // 保存左相机参数
        let left_params = CameraParams {
            camera_matrix: mat_to_vec2d_f64(left_camera_matrix),
            dist_coeffs: mat_to_vec_f64(left_dist_coeffs),
        };
        save_camera_params(&system_config.file_paths.left_camera_params_path, &left_params)
            .map_err(|e| format!("保存左相机参数失败: {}", e))?;
        
        // 保存右相机参数
        let right_params = CameraParams {
            camera_matrix: mat_to_vec2d_f64(right_camera_matrix),
            dist_coeffs: mat_to_vec_f64(right_dist_coeffs),
        };
        save_camera_params(&system_config.file_paths.right_camera_params_path, &right_params)
            .map_err(|e| format!("保存右相机参数失败: {}", e))?;
        
        // 保存双目参数
        let stereo_params = StereoParams {
            r: mat_to_vec2d_f64(r_matrix),
            t: mat_to_vec_f64(t_vector),
        };
        save_stereo_params(&system_config.file_paths.stereo_params_path, &stereo_params)
            .map_err(|e| format!("保存双目参数失败: {}", e))?;
        
        // 保存重映射参数
        let rectify_params = RectifyParams {
            r1: mat_to_vec2d_f64(&rectify_maps.r1),
            r2: mat_to_vec2d_f64(&rectify_maps.r2),
            p1: mat_to_vec2d_f64(&rectify_maps.p1),
            p2: mat_to_vec2d_f64(&rectify_maps.p2),
            q: mat_to_vec2d_f64(&rectify_maps.q),
        };
        save_rectify_params(&system_config.file_paths.rectify_params_path, &rectify_params)
            .map_err(|e| format!("保存重映射参数失败: {}", e))?;
        
        // 保存重映射矩阵
        let rectify_lr_maps = RectifyLeftRightMaps {
            left_map1: mat_to_vec2d_f32(left_map1),
            left_map2: mat_to_vec2d_f32(left_map2),
            right_map1: mat_to_vec2d_f32(right_map1),
            right_map2: mat_to_vec2d_f32(right_map2),
        };
        save_rectify_maps(&system_config.file_paths.rectify_maps_path, &rectify_lr_maps)
            .map_err(|e| format!("保存重映射矩阵失败: {}", e))?;
        
        println!("✅ 所有标定参数已保存");
        
        Ok(CalibrationFiles {
            left_camera_params: Some(system_config.file_paths.left_camera_params_path.clone()),
            right_camera_params: Some(system_config.file_paths.right_camera_params_path.clone()),
            stereo_params: Some(system_config.file_paths.stereo_params_path.clone()),
            rectify_params: Some(system_config.file_paths.rectify_params_path.clone()),
            rectify_maps: Some(system_config.file_paths.rectify_maps_path.clone()),
        })
    }
    
    /// 取消标定流程
    pub fn cancel_calibration(&mut self) -> Result<(), String> {
        if !self.calibration_running.load(Ordering::SeqCst) {
            return Ok(()); // 没有运行中的标定
        }
        
        println!("⏹️ 取消标定流程...");
        self.calibration_running.store(false, Ordering::SeqCst);
        
        // 重置进度
        let mut progress = self.calibration_progress.lock().unwrap();
        progress.current_stage = CalibrationStage::Idle;
        progress.progress_percentage = 0.0;
        progress.stage_description = "标定已取消".to_string();
        progress.estimated_remaining_time = 0;
        
        println!("✅ 标定流程已取消");
        Ok(())
    }
    
    /// 处理标定错误并生成用户指导
    pub fn handle_calibration_error(&self, error: CalibrationError) -> UserGuidance {
        match error {
            CalibrationError::InsufficientImages => UserGuidance {
                title: "图像数量不足".to_string(),
                message: "需要至少8组有效的标定图像才能进行标定".to_string(),
                actions: vec![
                    "继续采集更多标定图像".to_string(),
                    "确保标定板在每张图像中都清晰可见".to_string(),
                    "尝试不同的角度和位置拍摄".to_string(),
                ],
                can_retry: true,
            },
            CalibrationError::FeatureDetectionFailed => UserGuidance {
                title: "特征点检测失败".to_string(),
                message: "无法在图像中检测到标定板特征点".to_string(),
                actions: vec![
                    "确保标定板完全在图像范围内".to_string(),
                    "检查图像清晰度，避免模糊".to_string(),
                    "确保光照充足且均匀".to_string(),
                    "检查标定板是否有损坏或污渍".to_string(),
                ],
                can_retry: true,
            },
            CalibrationError::HighReprojectionError => UserGuidance {
                title: "标定精度不足".to_string(),
                message: "重投影误差过大，标定质量不符合要求".to_string(),
                actions: vec![
                    "确保标定板完全平整，无弯曲变形".to_string(),
                    "增加不同角度和位置的标定图像".to_string(),
                    "确保标定板在图像中清晰可见".to_string(),
                    "避免标定板反光或阴影遮挡".to_string(),
                    "检查相机固定是否稳定".to_string(),
                ],
                can_retry: true,
            },
            CalibrationError::CalibrationFailed => UserGuidance {
                title: "标定算法失败".to_string(),
                message: "标定算法计算失败，可能是输入数据有问题".to_string(),
                actions: vec![
                    "检查所有图像是否正确加载".to_string(),
                    "重新采集标定图像".to_string(),
                    "确保左右相机图像正确配对".to_string(),
                    "联系技术支持".to_string(),
                ],
                can_retry: true,
            },
            CalibrationError::FileSystemError => UserGuidance {
                title: "文件系统错误".to_string(),
                message: "无法读取或写入标定文件".to_string(),
                actions: vec![
                    "检查文件路径是否正确".to_string(),
                    "确保有足够的磁盘空间".to_string(),
                    "检查文件权限设置".to_string(),
                    "重启应用程序".to_string(),
                ],
                can_retry: true,
            },
            CalibrationError::ConfigurationError => UserGuidance {
                title: "配置错误".to_string(),
                message: "系统配置有误，无法进行标定".to_string(),
                actions: vec![
                    "检查系统配置文件".to_string(),
                    "重置为默认配置".to_string(),
                    "联系技术支持".to_string(),
                ],
                can_retry: false,
            },
            CalibrationError::CameraError => UserGuidance {
                title: "相机操作错误".to_string(),
                message: "相机操作失败，无法采集图像".to_string(),
                actions: vec![
                    "检查相机连接".to_string(),
                    "重启相机".to_string(),
                    "检查相机驱动".to_string(),
                    "联系技术支持".to_string(),
                ],
                can_retry: true,
            },
        }
    }
}

impl Default for CaptureConfig {
    fn default() -> Self {
        Self {
            preview_fps: 10,
            capture_resolution: (2448, 2048),
            thumbnail_size: (200, 166),
            save_directory: "calibration_images".to_string(),
            image_format: "png".to_string(),
        }
    }
} 