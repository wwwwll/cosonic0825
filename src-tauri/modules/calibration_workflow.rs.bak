//! ç›¸æœºæ ‡å®šå·¥ä½œæµç¨‹ç®¡ç†æ¨¡å—
//! 
//! åŸºäºç°æœ‰çš„calibration_circles.rsç®—æ³•å’Œcamera_workflow.rsç›¸æœºæ§åˆ¶ï¼Œ
//! æä¾›å®Œæ•´çš„ç”¨æˆ·å‹å¥½æ ‡å®šå·¥ä½œæµç¨‹ã€‚
//! 
//! ## ğŸ¯ æ ¸å¿ƒåŠŸèƒ½
//! 
//! ### æ ‡å®šçŠ¶æ€æ£€æµ‹å’Œç®¡ç†
//! - æ£€æµ‹ç°æœ‰æ ‡å®šç»“æœï¼Œæç¤ºæ ‡å®šéœ€æ±‚
//! - éªŒè¯æ ‡å®šæ–‡ä»¶å®Œæ•´æ€§å’Œæœ‰æ•ˆæ€§
//! - æ ‡å®šæ–‡ä»¶çŠ¶æ€ç®¡ç†
//! 
//! ### æ ‡å®šå›¾åƒé‡‡é›†å·¥ä½œæµ
//! - ç®¡ç†10ç»„åŒç›®å›¾åƒçš„é‡‡é›†æµç¨‹
//! - å®æ—¶é¢„è§ˆå’Œç¼©ç•¥å›¾ç®¡ç†
//! - å›¾åƒè´¨é‡æ£€æµ‹å’ŒéªŒè¯
//! 
//! ### æ ‡å®šç®—æ³•æµç¨‹æ§åˆ¶
//! - å•ç›®â†’åŒç›®â†’é‡æ˜ å°„çŸ©é˜µçš„å®Œæ•´æ ‡å®šæµç¨‹
//! - è¿›åº¦ç›‘æ§å’ŒçŠ¶æ€åé¦ˆ
//! - åŸºäºç°æœ‰calibration_circles.rsç®—æ³•
//! 
//! ### æ ‡å®šç»“æœéªŒè¯å’Œä¿å­˜
//! - é‡æŠ•å½±è¯¯å·®æ£€æŸ¥å’Œè´¨é‡è¯„ä¼°
//! - å‚æ•°ä¿å­˜å’ŒåŠ è½½ç®¡ç†
//! - ç”¨æˆ·æŒ‡å¯¼å’Œé”™è¯¯å¤„ç†

use std::{
    path::PathBuf,
    fs,
    sync::{Arc, Mutex, atomic::{AtomicBool, Ordering}},
    thread,
    time::{Duration, SystemTime, UNIX_EPOCH},

};

use opencv::{
    core::{Mat, Size, Point2f, Point3f, Vector},
    imgcodecs,
    imgproc,

};

use serde::{Serialize, Deserialize};
use base64::{Engine as _, engine::general_purpose};

use crate::config::SystemConfig;
use crate::modules::{
    calibration_circles::{Calibrator, MonoCalibResult, StereoCalibResult, MonoCamera},
    param_io::*,
    //camera_workflow::CameraWorkflowManager,
};

/// æ ‡å®šçŠ¶æ€æšä¸¾
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum CalibrationStatus {
    /// æœªæ ‡å®š - ç¼ºå°‘å¿…è¦çš„æ ‡å®šæ–‡ä»¶
    NotCalibrated,
    /// éƒ¨åˆ†æ ‡å®š - æŸäº›æ ‡å®šæ–‡ä»¶å­˜åœ¨ä½†ä¸å®Œæ•´
    PartiallyCalibrated,
    /// å®Œæ•´æ ‡å®š - æ‰€æœ‰æ ‡å®šæ–‡ä»¶å­˜åœ¨ä¸”æœ‰æ•ˆ
    FullyCalibrated,
    /// æ ‡å®šè¿‡æœŸ - æ ‡å®šæ–‡ä»¶æŸåæˆ–ç‰ˆæœ¬ä¸å…¼å®¹
    CalibrationExpired,
}

/// æ ‡å®šæ–‡ä»¶ä¿¡æ¯
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CalibrationFiles {
    pub left_camera_params: Option<String>,      // å·¦ç›¸æœºå†…å‚æ–‡ä»¶è·¯å¾„
    pub right_camera_params: Option<String>,     // å³ç›¸æœºå†…å‚æ–‡ä»¶è·¯å¾„
    pub stereo_params: Option<String>,           // åŒç›®æ ‡å®šå‚æ•°è·¯å¾„
    pub rectify_params: Option<String>,          // é‡æ˜ å°„å‚æ•°è·¯å¾„
    pub rectify_maps: Option<String>,            // é‡æ˜ å°„çŸ©é˜µè·¯å¾„
}

/// å›¾åƒé‡‡é›†é˜¶æ®µ
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum CaptureStage {
    /// ç©ºé—²çŠ¶æ€
    Idle,
    /// é¢„è§ˆæ¨¡å¼ - ç›¸æœºå®æ—¶é¢„è§ˆ
    PreviewMode,
    /// å‡†å¤‡æ‹æ‘„ - ç­‰å¾…ç”¨æˆ·æ“ä½œ
    ReadyToCapture,
    /// æ­£åœ¨æ‹æ‘„ - é‡‡é›†åŒç›®å›¾åƒ
    Capturing,
    /// å›¾åƒå·²ä¿å­˜ - å•æ¬¡é‡‡é›†å®Œæˆ
    ImageSaved,
    /// é‡‡é›†å®Œæˆ - è¾¾åˆ°ç›®æ ‡æ•°é‡
    CaptureComplete,
}

/// æ ‡å®šç®—æ³•é˜¶æ®µ
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum CalibrationStage {
    /// ç©ºé—²çŠ¶æ€
    Idle,
    /// åŠ è½½å›¾åƒå’Œæ£€æµ‹ç‰¹å¾ç‚¹
    LoadingImages,
    /// æ£€æµ‹ç‰¹å¾ç‚¹
    DetectingFeatures,
    /// å·¦ç›¸æœºå•ç›®æ ‡å®š
    LeftMonoCalibration,
    /// å³ç›¸æœºå•ç›®æ ‡å®š
    RightMonoCalibration,
    /// åŒç›®æ ‡å®š
    StereoCalibration,
    /// è®¡ç®—é‡æ˜ å°„çŸ©é˜µ
    ComputingRectification,
    /// éªŒè¯æ ‡å®šç»“æœ
    ValidatingResults,
    /// ä¿å­˜å‚æ•°æ–‡ä»¶
    SavingParameters,
    /// æ ‡å®šå®Œæˆ
    Completed,
    /// æ ‡å®šé”™è¯¯
    Error(String),
}

/// å›¾åƒå¯¹ä¿¡æ¯
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ImagePair {
    pub pair_id: u32,
    pub left_image_path: String,
    pub right_image_path: String,
    pub thumbnail_left: String,       // Base64ç¼©ç•¥å›¾
    pub thumbnail_right: String,      // Base64ç¼©ç•¥å›¾
    pub capture_timestamp: String,
    pub is_valid: bool,               // æ˜¯å¦æ£€æµ‹åˆ°æ ‡å®šæ¿
    pub feature_count: u32,           // æ£€æµ‹åˆ°çš„ç‰¹å¾ç‚¹æ•°é‡
}

/// é‡‡é›†ä¼šè¯ä¿¡æ¯
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CaptureSession {
    pub session_id: String,           // ä¼šè¯ID
    pub target_image_count: u32,      // ç›®æ ‡å›¾åƒæ•°é‡ï¼ˆé»˜è®¤10ï¼‰
    pub captured_images: Vec<ImagePair>,
    pub current_stage: CaptureStage,
    pub capture_config: CaptureConfig,
    pub created_at: String,
}

/// é‡‡é›†é…ç½®
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CaptureConfig {
    pub preview_fps: u32,             // é¢„è§ˆå¸§ç‡
    pub capture_resolution: (u32, u32), // é‡‡é›†åˆ†è¾¨ç‡
    pub thumbnail_size: (u32, u32),   // ç¼©ç•¥å›¾å°ºå¯¸
    pub save_directory: String,       // å›¾åƒä¿å­˜ç›®å½•
    pub image_format: String,         // å›¾åƒæ ¼å¼ (png/jpg)
}

/// æ ‡å®šè¿›åº¦ä¿¡æ¯
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CalibrationProgress {
    pub current_stage: CalibrationStage,
    pub progress_percentage: f32,      // 0-100
    pub stage_description: String,     // å½“å‰é˜¶æ®µæè¿°
    pub estimated_remaining_time: u32, // é¢„ä¼°å‰©ä½™æ—¶é—´ï¼ˆç§’ï¼‰
    pub processed_images: u32,         // å·²å¤„ç†å›¾åƒæ•°é‡
    pub total_images: u32,             // æ€»å›¾åƒæ•°é‡
}

/// ç›¸æœºè´¨é‡è¯„ä¼°
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CameraQuality {
    pub rms_error: f64,               // RMSé‡æŠ•å½±è¯¯å·®
    pub max_error: f64,               // æœ€å¤§é‡æŠ•å½±è¯¯å·®
    pub mean_error: f64,              // å¹³å‡é‡æŠ•å½±è¯¯å·®
    pub coverage_score: f32,          // æ ‡å®šæ¿è¦†ç›–åº¦è¯„åˆ† (0-100)
    pub angle_diversity: f32,         // è§’åº¦å¤šæ ·æ€§è¯„åˆ† (0-100)
}

/// åŒç›®è´¨é‡è¯„ä¼°
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct StereoQuality {
    pub stereo_rms_error: f64,        // åŒç›®æ ‡å®šRMSè¯¯å·®
    pub epipolar_error: f64,          // æçº¿çº¦æŸè¯¯å·®
    pub baseline_accuracy: f64,       // åŸºçº¿ç²¾åº¦
}

/// è´¨é‡ç­‰çº§
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum QualityGrade {
    Excellent,  // ä¼˜ç§€ (RMS < 0.5)
    Good,       // è‰¯å¥½ (RMS < 1.0)
    Acceptable, // å¯æ¥å— (RMS < 2.0)
    Poor,       // è¾ƒå·® (RMS >= 2.0)
}

/// æ ‡å®šè´¨é‡è¯„ä¼°
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CalibrationQuality {
    pub overall_grade: QualityGrade,   // æ€»ä½“è¯„çº§
    pub left_camera_quality: CameraQuality,
    pub right_camera_quality: CameraQuality,
    pub stereo_quality: StereoQuality,
    pub recommendations: Vec<String>,   // æ”¹è¿›å»ºè®®
}

/// æ ‡å®šç»“æœ
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CalibrationResult {
    pub success: bool,
    pub left_rms_error: f64,           // å·¦ç›¸æœºé‡æŠ•å½±è¯¯å·®
    pub right_rms_error: f64,          // å³ç›¸æœºé‡æŠ•å½±è¯¯å·®
    pub stereo_rms_error: f64,         // åŒç›®æ ‡å®šè¯¯å·®
    pub error_threshold: f64,          // é”™è¯¯é˜ˆå€¼
    pub error_message: Option<String>, // é”™è¯¯ä¿¡æ¯
    pub saved_files: CalibrationFiles, // ä¿å­˜çš„æ–‡ä»¶è·¯å¾„
    pub quality: Option<CalibrationQuality>, // è´¨é‡è¯„ä¼°
    pub calibration_time: String,      // æ ‡å®šå®Œæˆæ—¶é—´
}

/// æ ‡å®šé”™è¯¯ç±»å‹
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum CalibrationError {
    InsufficientImages,      // å›¾åƒæ•°é‡ä¸è¶³
    FeatureDetectionFailed,  // ç‰¹å¾ç‚¹æ£€æµ‹å¤±è´¥
    CalibrationFailed,       // æ ‡å®šç®—æ³•å¤±è´¥
    HighReprojectionError,   // é‡æŠ•å½±è¯¯å·®è¿‡å¤§
    FileSystemError,         // æ–‡ä»¶ç³»ç»Ÿé”™è¯¯
    ConfigurationError,      // é…ç½®é”™è¯¯
    CameraError,             // ç›¸æœºæ“ä½œé”™è¯¯
}

/// ç”¨æˆ·æŒ‡å¯¼ä¿¡æ¯
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UserGuidance {
    pub title: String,
    pub message: String,
    pub actions: Vec<String>,
    pub can_retry: bool,
}

/// æ ‡å®šå·¥ä½œæµç¨‹ç®¡ç†å™¨
pub struct CalibrationWorkflow {
    system_config: SystemConfig,
    current_status: CalibrationStatus,
    calibration_files: CalibrationFiles,
    
    // å›¾åƒé‡‡é›†ç›¸å…³
    capture_session: Option<CaptureSession>,
    //camera_workflow: Option<CameraWorkflowManager>,
    
    // æ ‡å®šç®—æ³•ç›¸å…³
    calibrator: Option<Calibrator>,
    calibration_progress: Arc<Mutex<CalibrationProgress>>,
    calibration_running: Arc<AtomicBool>,
    
    // ç»“æœå­˜å‚¨
    last_calibration_result: Option<CalibrationResult>,
}

impl CalibrationWorkflow {
    /// åˆ›å»ºæ–°çš„æ ‡å®šå·¥ä½œæµç¨‹ç®¡ç†å™¨
    pub fn new(system_config: SystemConfig) -> Result<Self, String> {
        println!("ğŸ—ï¸ åˆå§‹åŒ–æ ‡å®šå·¥ä½œæµç¨‹ç®¡ç†å™¨...");
        
        let calibration_files = CalibrationFiles {
            left_camera_params: Some(system_config.file_paths.left_camera_params_path.clone()),
            right_camera_params: Some(system_config.file_paths.right_camera_params_path.clone()),
            stereo_params: Some(system_config.file_paths.stereo_params_path.clone()),
            rectify_params: Some(system_config.file_paths.rectify_params_path.clone()),
            rectify_maps: Some(system_config.file_paths.rectify_maps_path.clone()),
        };
        
        let initial_progress = CalibrationProgress {
            current_stage: CalibrationStage::Idle,
            progress_percentage: 0.0,
            stage_description: "ç­‰å¾…å¼€å§‹æ ‡å®š".to_string(),
            estimated_remaining_time: 0,
            processed_images: 0,
            total_images: 0,
        };
        
        let mut workflow = Self {
            current_status: CalibrationStatus::NotCalibrated,
            calibration_files,
            system_config,
            capture_session: None,
            //camera_workflow: None,
            calibrator: None,
            calibration_progress: Arc::new(Mutex::new(initial_progress)),
            calibration_running: Arc::new(AtomicBool::new(false)),
            last_calibration_result: None,
        };
        
        // æ£€æµ‹å½“å‰æ ‡å®šçŠ¶æ€
        workflow.detect_calibration_status()?;
        
        println!("âœ… æ ‡å®šå·¥ä½œæµç¨‹ç®¡ç†å™¨åˆå§‹åŒ–å®Œæˆ");
        Ok(workflow)
    }
    
    /// æ£€æµ‹å½“å‰æ ‡å®šçŠ¶æ€
    pub fn detect_calibration_status(&mut self) -> Result<CalibrationStatus, String> {
        println!("ğŸ” æ£€æµ‹æ ‡å®šçŠ¶æ€...");
        
        let mut existing_files = 0;
        let mut valid_files = 0;
        
        // æ£€æŸ¥å·¦ç›¸æœºå‚æ•°
        if let Some(path) = &self.calibration_files.left_camera_params {
            if PathBuf::from(path).exists() {
                existing_files += 1;
                if self.validate_camera_params_file(path).is_ok() {
                    valid_files += 1;
                }
            }
        }
        
        // æ£€æŸ¥å³ç›¸æœºå‚æ•°
        if let Some(path) = &self.calibration_files.right_camera_params {
            if PathBuf::from(path).exists() {
                existing_files += 1;
                if self.validate_camera_params_file(path).is_ok() {
                    valid_files += 1;
                }
            }
        }
        
        // æ£€æŸ¥åŒç›®å‚æ•°
        if let Some(path) = &self.calibration_files.stereo_params {
            if PathBuf::from(path).exists() {
                existing_files += 1;
                if self.validate_stereo_params_file(path).is_ok() {
                    valid_files += 1;
                }
            }
        }
        
        // æ£€æŸ¥é‡æ˜ å°„å‚æ•°
        if let Some(path) = &self.calibration_files.rectify_params {
            if PathBuf::from(path).exists() {
                existing_files += 1;
                if self.validate_rectify_params_file(path).is_ok() {
                    valid_files += 1;
                }
            }
        }
        
        // ç¡®å®šæ ‡å®šçŠ¶æ€
        let status = match (existing_files, valid_files) {
            (0, 0) => CalibrationStatus::NotCalibrated,
            (n, v) if n == v && n >= 4 => CalibrationStatus::FullyCalibrated,
            (n, v) if n > 0 && v < n => CalibrationStatus::CalibrationExpired,
            _ => CalibrationStatus::PartiallyCalibrated,
        };
        
        self.current_status = status.clone();
        
        println!("ğŸ“Š æ ‡å®šçŠ¶æ€æ£€æµ‹å®Œæˆ: {:?} (å­˜åœ¨æ–‡ä»¶: {}, æœ‰æ•ˆæ–‡ä»¶: {})", 
                status, existing_files, valid_files);
        
        Ok(status)
    }
    
    /// éªŒè¯ç›¸æœºå‚æ•°æ–‡ä»¶
    fn validate_camera_params_file(&self, path: &str) -> Result<(), String> {
        load_camera_params(path)
            .map_err(|e| format!("ç›¸æœºå‚æ•°æ–‡ä»¶æ— æ•ˆ: {}", e))?;
        Ok(())
    }
    
    /// éªŒè¯åŒç›®å‚æ•°æ–‡ä»¶
    fn validate_stereo_params_file(&self, path: &str) -> Result<(), String> {
        load_stereo_params(path)
            .map_err(|e| format!("åŒç›®å‚æ•°æ–‡ä»¶æ— æ•ˆ: {}", e))?;
        Ok(())
    }
    
    /// éªŒè¯é‡æ˜ å°„å‚æ•°æ–‡ä»¶
    fn validate_rectify_params_file(&self, path: &str) -> Result<(), String> {
        load_rectify_params(path)
            .map_err(|e| format!("é‡æ˜ å°„å‚æ•°æ–‡ä»¶æ— æ•ˆ: {}", e))?;
        Ok(())
    }
    
    /// è·å–å½“å‰æ ‡å®šçŠ¶æ€
    pub fn get_calibration_status(&self) -> CalibrationStatus {
        self.current_status.clone()
    }
    
    /// è·å–æ ‡å®šæ–‡ä»¶ä¿¡æ¯
    pub fn get_calibration_files_info(&self) -> CalibrationFiles {
        self.calibration_files.clone()
    }
    
    /// å¼€å§‹æ ‡å®šå›¾åƒé‡‡é›†ä¼šè¯
    pub fn start_calibration_capture(&mut self) -> Result<String, String> {
        println!("ğŸ¬ å¼€å§‹æ ‡å®šå›¾åƒé‡‡é›†ä¼šè¯...");
        
        // åˆ›å»ºé‡‡é›†ä¼šè¯ID
        let session_id = format!("calibration_{}", 
            SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs());
        
        // åˆ›å»ºä¿å­˜ç›®å½•
        let save_directory = format!("calibration_images/{}", session_id);
        fs::create_dir_all(&save_directory)
            .map_err(|e| format!("åˆ›å»ºä¿å­˜ç›®å½•å¤±è´¥: {}", e))?;
        
        // åˆ›å»ºé‡‡é›†é…ç½®
        let capture_config = CaptureConfig {
            preview_fps: 10,
            capture_resolution: (2448, 2048),
            thumbnail_size: (200, 166),
            save_directory: save_directory.clone(),
            image_format: "png".to_string(),
        };
        
        // åˆ›å»ºé‡‡é›†ä¼šè¯
        let capture_session = CaptureSession {
            session_id: session_id.clone(),
            target_image_count: 10,
            captured_images: Vec::new(),
            current_stage: CaptureStage::Idle,
            capture_config,
            created_at: chrono::Utc::now().to_rfc3339(),
        };
        
        self.capture_session = Some(capture_session);
        
        // åˆå§‹åŒ–ç›¸æœºå·¥ä½œæµç¨‹
        // æ³¨é‡Šæ‰å› ä¸ºcamera_workflowæ¨¡å—æ²¡æœ‰å®ç°
        // if self.camera_workflow.is_none() {
        //     self.camera_workflow = Some(CameraWorkflowManager::new()
        //         .map_err(|e| format!("ç›¸æœºåˆå§‹åŒ–å¤±è´¥: {:?}", e))?);
        // }
        
        // åˆ‡æ¢åˆ°é¢„è§ˆæ¨¡å¼
        // if let Some(camera) = &mut self.camera_workflow {
        //     camera.switch_stage(crate::camera_ffi::Stage::Preview)
        //         .map_err(|e| format!("åˆ‡æ¢åˆ°é¢„è§ˆæ¨¡å¼å¤±è´¥: {:?}", e))?;
        // }
        
        // æ›´æ–°ä¼šè¯çŠ¶æ€
        if let Some(session) = &mut self.capture_session {
            session.current_stage = CaptureStage::PreviewMode;
        }
        
        println!("âœ… æ ‡å®šå›¾åƒé‡‡é›†ä¼šè¯å·²å¯åŠ¨: {}", session_id);
        Ok(session_id)
    }
    
    /// æ‹æ‘„ä¸€ç»„åŒç›®æ ‡å®šå›¾åƒ
    pub fn capture_calibration_image(&mut self) -> Result<String, String> {
        println!("ğŸ“¸ æ‹æ‘„æ ‡å®šå›¾åƒå¯¹...");
        
        let session = self.capture_session.as_mut()
            .ok_or("æ²¡æœ‰æ´»åŠ¨çš„é‡‡é›†ä¼šè¯")?;
        
        if session.current_stage != CaptureStage::PreviewMode && 
           session.current_stage != CaptureStage::ReadyToCapture {
            return Err("å½“å‰çŠ¶æ€ä¸å…è®¸æ‹æ‘„".to_string());
        }
        
        // æ›´æ–°çŠ¶æ€
        session.current_stage = CaptureStage::Capturing;
        
        // è·å–ç›¸æœºå·¥ä½œæµç¨‹
        // let camera = self.camera_workflow.as_mut()
        //     .ok_or("ç›¸æœºå·¥ä½œæµç¨‹æœªåˆå§‹åŒ–")?;
        
        // åˆ‡æ¢åˆ°æ£€æµ‹æ¨¡å¼è¿›è¡Œé«˜è´¨é‡é‡‡é›†
        // camera.switch_stage(crate::camera_ffi::Stage::Detection)
        //     .map_err(|e| format!("åˆ‡æ¢åˆ°æ£€æµ‹æ¨¡å¼å¤±è´¥: {:?}", e))?;
        
        // ç­‰å¾…ç›¸æœºç¨³å®š
        thread::sleep(Duration::from_millis(500));
        
        // æ‰§è¡ŒåŒç›®åŒæ­¥é‡‡é›†
        let pair_id = session.captured_images.len() as u32;
        let timestamp = chrono::Utc::now().to_rfc3339();
        
        let left_image_path = format!("{}/left_{:02}.png", 
            session.capture_config.save_directory, pair_id);
        let right_image_path = format!("{}/right_{:02}.png", 
            session.capture_config.save_directory, pair_id);
        
        // æ‰§è¡ŒåŒç›®ç›¸æœºé‡‡é›†
        // TODO: è¿ç§»åˆ°ä½¿ç”¨CameraManagerç»Ÿä¸€æ¥å£
        return Err("å›¾åƒé‡‡é›†åŠŸèƒ½éœ€è¦é‡æ„ä»¥ä½¿ç”¨CameraManageræ¥å£".to_string());
        
        // åˆ‡æ¢å›é¢„è§ˆæ¨¡å¼
        // camera.switch_stage(crate::camera_ffi::Stage::Preview)
        //     .map_err(|e| format!("åˆ‡æ¢å›é¢„è§ˆæ¨¡å¼å¤±è´¥: {:?}", e))?;
        
        // // è·å–ç¼©ç•¥å›¾å°ºå¯¸ï¼ˆé¿å…å€Ÿç”¨å†²çªï¼‰
        // let thumbnail_size = session.capture_config.thumbnail_size;
        
        // // é‡Šæ”¾æ‰€æœ‰å¯å˜å€Ÿç”¨
        // drop(session);
        // drop(camera);
        
        // æ£€æµ‹æ ‡å®šæ¿ç‰¹å¾ç‚¹
        let (is_valid, feature_count) = self.validate_calibration_image_pair(
            &left_image_path, &right_image_path)?;
        
        // ç”Ÿæˆç¼©ç•¥å›¾
        // let thumbnail_left = self.generate_thumbnail(&left_image_path, thumbnail_size)?;
        // let thumbnail_right = self.generate_thumbnail(&right_image_path, thumbnail_size)?;
        
        // åˆ›å»ºå›¾åƒå¯¹ä¿¡æ¯
        // let image_pair = ImagePair {
        //     pair_id,
        //     left_image_path,
        //     right_image_path,
        //     //thumbnail_left,
        //     //thumbnail_right,
        //     capture_timestamp: timestamp,
        //     is_valid,
        //     feature_count,
        // };
        
        // é‡æ–°è·å–sessionçš„å¯å˜å¼•ç”¨æ¥ä¿å­˜ç»“æœ
        let session = self.capture_session.as_mut().unwrap();
        
        // ä¿å­˜åˆ°ä¼šè¯ä¸­
        //session.captured_images.push(image_pair.clone());
        
        // æ›´æ–°ä¼šè¯çŠ¶æ€
        if session.captured_images.len() >= session.target_image_count as usize {
            session.current_stage = CaptureStage::CaptureComplete;
        } else {
            session.current_stage = CaptureStage::ReadyToCapture;
        }
        
        println!("âœ… æ ‡å®šå›¾åƒå¯¹é‡‡é›†å®Œæˆ: {} (æœ‰æ•ˆ: {}, ç‰¹å¾ç‚¹: {})", 
                pair_id, is_valid, feature_count);
        
        Ok("ç”±äºcamera_manager.rsé‡æ„æµ‹è¯•,æš‚æ—¶è·³è¿‡è¯¥å‡½æ•°".to_string())
    }
    

    
    /// æ¨¡æ‹ŸåŒç›®é‡‡é›†çš„åå¤‡æ–¹æ¡ˆ (ä»…ç”¨äºæµ‹è¯•)
    fn simulate_dual_camera_capture_fallback(&self, left_path: &str, right_path: &str) -> Result<(), String> {
        // TODO: å½“camera_workflowé›†æˆå®Œæˆåï¼Œå¯ä»¥ç§»é™¤æ­¤å‡½æ•°
        // è¿™é‡Œåˆ›å»ºç©ºç™½å›¾åƒä½œä¸ºå ä½ç¬¦
        let image = Mat::zeros(2048, 2448, opencv::core::CV_8UC3)
            .map_err(|e| format!("åˆ›å»ºå›¾åƒå¤±è´¥: {}", e))?;
        
        imgcodecs::imwrite(left_path, &image, &Vector::new())
            .map_err(|e| format!("ä¿å­˜å·¦å›¾åƒå¤±è´¥: {}", e))?;
        
        imgcodecs::imwrite(right_path, &image, &Vector::new())
            .map_err(|e| format!("ä¿å­˜å³å›¾åƒå¤±è´¥: {}", e))?;
        
        println!("ğŸ“· æ¨¡æ‹ŸåŒç›®å›¾åƒé‡‡é›†å®Œæˆï¼ˆåå¤‡æ–¹æ¡ˆï¼‰: {} | {}", left_path, right_path);
        Ok(())
    }
    
    /// éªŒè¯æ ‡å®šå›¾åƒå¯¹
    fn validate_calibration_image_pair(&self, left_path: &str, right_path: &str) -> Result<(bool, u32), String> {
        // 1. éªŒè¯å›¾åƒæ–‡ä»¶æ˜¯å¦å­˜åœ¨å’Œæœ‰æ•ˆ
        let files_valid = crate::modules::param_io::validate_stereo_image_pair(left_path, right_path)
            .map_err(|e| format!("éªŒè¯å›¾åƒæ–‡ä»¶å¤±è´¥: {}", e))?;
        
        if !files_valid {
            return Ok((false, 0));
        }
        
        // 2. TODO: ä½¿ç”¨calibration_circles.rsæ£€æµ‹ç‰¹å¾ç‚¹
        // å®é™…å®ç°æ—¶çš„é€»è¾‘ï¼š
        // let left_image = opencv::imgcodecs::imread(left_path, opencv::imgcodecs::IMREAD_COLOR)?;
        // let right_image = opencv::imgcodecs::imread(right_path, opencv::imgcodecs::IMREAD_COLOR)?;
        // let (left_corners, left_ids) = calibrator.detect_corners(&left_image)?;
        // let (right_corners, right_ids) = calibrator.detect_corners(&right_image)?;
        // let feature_count = left_corners.len().min(right_corners.len()) as u32;
        
        // å½“å‰è¿”å›æ¨¡æ‹Ÿç»“æœ
        Ok((true, 40)) // å‡è®¾æ£€æµ‹åˆ°40ä¸ªç‰¹å¾ç‚¹
    }
    
    /// ç”Ÿæˆç¼©ç•¥å›¾
    fn generate_thumbnail(&self, image_path: &str, size: (u32, u32)) -> Result<String, String> {
        let image = imgcodecs::imread(image_path, imgcodecs::IMREAD_COLOR)
            .map_err(|e| format!("è¯»å–å›¾åƒå¤±è´¥: {}", e))?;
        
        let mut thumbnail = Mat::default();
        imgproc::resize(&image, &mut thumbnail, 
            opencv::core::Size::new(size.0 as i32, size.1 as i32),
            0.0, 0.0, imgproc::INTER_LINEAR)
            .map_err(|e| format!("ç¼©æ”¾å›¾åƒå¤±è´¥: {}", e))?;
        
        // ç¼–ç ä¸ºPNG
        let mut buffer = Vector::new();
        imgcodecs::imencode(".png", &thumbnail, &mut buffer, &Vector::new())
            .map_err(|e| format!("ç¼–ç å›¾åƒå¤±è´¥: {}", e))?;
        
        // è½¬æ¢ä¸ºBase64
        let base64_str = general_purpose::STANDARD.encode(buffer.as_slice());
        Ok(format!("data:image/png;base64,{}", base64_str))
    }
    
    /// è·å–å·²é‡‡é›†çš„å›¾åƒåˆ—è¡¨
    pub fn get_captured_images(&self) -> Result<Vec<ImagePair>, String> {
        let session = self.capture_session.as_ref()
            .ok_or("æ²¡æœ‰æ´»åŠ¨çš„é‡‡é›†ä¼šè¯")?;
        
        Ok(session.captured_images.clone())
    }
    
    /// åˆ é™¤æŒ‡å®šçš„å›¾åƒå¯¹
    pub fn delete_captured_image(&mut self, pair_id: u32) -> Result<(), String> {
        let session = self.capture_session.as_mut()
            .ok_or("æ²¡æœ‰æ´»åŠ¨çš„é‡‡é›†ä¼šè¯")?;
        
        // æ‰¾åˆ°å¹¶åˆ é™¤å›¾åƒå¯¹
        let index = session.captured_images.iter()
            .position(|img| img.pair_id == pair_id)
            .ok_or("æ‰¾ä¸åˆ°æŒ‡å®šçš„å›¾åƒå¯¹")?;
        
        let image_pair = session.captured_images.remove(index);
        
        // åˆ é™¤æ–‡ä»¶
        let _ = fs::remove_file(&image_pair.left_image_path);
        let _ = fs::remove_file(&image_pair.right_image_path);
        
        // æ›´æ–°ä¼šè¯çŠ¶æ€
        if session.captured_images.len() < session.target_image_count as usize {
            session.current_stage = CaptureStage::ReadyToCapture;
        }
        
        println!("ğŸ—‘ï¸ å·²åˆ é™¤å›¾åƒå¯¹: {}", pair_id);
        Ok(())
    }
    
    /// å®Œæˆå›¾åƒé‡‡é›†
    pub fn finish_image_capture(&mut self) -> Result<bool, String> {
        let session = self.capture_session.as_ref()
            .ok_or("æ²¡æœ‰æ´»åŠ¨çš„é‡‡é›†ä¼šè¯")?;
        
        // æ£€æŸ¥æ˜¯å¦æ»¡è¶³æ ‡å®šè¦æ±‚
        let valid_images = session.captured_images.iter()
            .filter(|img| img.is_valid)
            .count();
        
        if valid_images < 8 {
            return Ok(false); // è‡³å°‘éœ€è¦8ç»„æœ‰æ•ˆå›¾åƒ
        }
        
        println!("âœ… å›¾åƒé‡‡é›†å®Œæˆï¼Œæœ‰æ•ˆå›¾åƒ: {}/{}", valid_images, session.captured_images.len());
        
        // æ³¨æ„ï¼šè¿™é‡Œä¸é‡Šæ”¾ç›¸æœºèµ„æºï¼Œåªæ˜¯å®Œæˆå›¾åƒé‡‡é›†é˜¶æ®µ
        // ç›¸æœºå°†ç»§ç»­ç”¨äºåç»­çš„æ ‡å®šè¿‡ç¨‹æˆ–å…¶ä»–å·¥ä½œæµç¨‹
        
        Ok(true)
    }
    
    /// å®Œæˆæ•´ä¸ªæ ‡å®šå·¥ä½œæµç¨‹å¹¶é‡Šæ”¾èµ„æº
    pub fn finish_calibration_workflow(&mut self) -> Result<(), String> {
        println!("ğŸ¯ æ ‡å®šå·¥ä½œæµç¨‹å®Œæˆï¼Œé‡Šæ”¾ç›¸æœºèµ„æº...");
        
        // // é‡Šæ”¾ç›¸æœºå·¥ä½œæµç¨‹èµ„æº
        // if let Some(mut camera_workflow) = self.camera_workflow.take() {
        //     camera_workflow.release().map_err(|e| format!("é‡Šæ”¾ç›¸æœºèµ„æºå¤±è´¥: {:?}", e))?;
        //     println!("ğŸ“· ç›¸æœºèµ„æºå·²é‡Šæ”¾");
        // }
        
        // æ¸…ç†æ ‡å®šä¼šè¯
        self.capture_session = None;
        self.last_calibration_result = None;
        
        // åœæ­¢æ ‡å®šæµç¨‹
        if self.calibration_running.load(Ordering::Relaxed) {
            self.calibration_running.store(false, Ordering::Relaxed);
        }
        
        println!("âœ… æ ‡å®šå·¥ä½œæµç¨‹èµ„æºæ¸…ç†å®Œæˆ");
        Ok(())
    }
    
    /// è·å–å½“å‰æ ‡å®šè¿›åº¦
    pub fn get_calibration_progress(&self) -> CalibrationProgress {
        self.calibration_progress.lock().unwrap().clone()
    }
    
    /// è·å–æœ€åçš„æ ‡å®šç»“æœ
    pub fn get_calibration_result(&self) -> Option<CalibrationResult> {
        self.last_calibration_result.clone()
    }
    
    /// å¼€å§‹æ ‡å®šè®¡ç®—æµç¨‹
    pub fn start_calibration_process(&mut self) -> Result<(), String> {
        println!("ğŸš€ å¼€å§‹æ ‡å®šè®¡ç®—æµç¨‹...");
        
        // æ£€æŸ¥æ˜¯å¦æœ‰è¶³å¤Ÿçš„å›¾åƒ
        let session = self.capture_session.as_ref()
            .ok_or("æ²¡æœ‰æ´»åŠ¨çš„é‡‡é›†ä¼šè¯")?;
        
        let valid_images: Vec<_> = session.captured_images.iter()
            .filter(|img| img.is_valid)
            .collect();
        
        if valid_images.len() < 8 {
            return Err(format!("æœ‰æ•ˆå›¾åƒæ•°é‡ä¸è¶³: {}/8", valid_images.len()));
        }
        
        // è®¾ç½®æ ‡å®šè¿è¡ŒçŠ¶æ€
        self.calibration_running.store(true, Ordering::SeqCst);
        
        // åˆå§‹åŒ–æ ‡å®šå™¨
        let (diameter, center_distance, pattern_size) = self.system_config.get_effective_pattern_params();
        let image_size = Size::new(
            session.capture_config.capture_resolution.0 as i32,
            session.capture_config.capture_resolution.1 as i32
        );
        
        self.calibrator = Some(Calibrator::new(
            image_size,
            diameter,
            center_distance,
            pattern_size,
            2.0, // é‡æŠ•å½±è¯¯å·®é˜ˆå€¼
        ).map_err(|e| format!("åˆ›å»ºæ ‡å®šå™¨å¤±è´¥: {}", e))?);
        
        // åœ¨åå°çº¿ç¨‹ä¸­è¿è¡Œæ ‡å®šæµç¨‹
        let captured_images = session.captured_images.clone();
        let progress_arc = self.calibration_progress.clone();
        let running_arc = self.calibration_running.clone();
        let system_config = self.system_config.clone();
        
        thread::spawn(move || {
            let result = Self::run_calibration_background(
                captured_images,
                system_config,
                progress_arc.clone(),
                running_arc.clone(),
            );
            
            match result {
                Ok(_calibration_result) => {
                    println!("âœ… æ ‡å®šæµç¨‹å®ŒæˆæˆåŠŸ");
                    // TODO: ä¿å­˜ç»“æœåˆ°ä¸»çº¿ç¨‹
                }
                Err(e) => {
                    println!("âŒ æ ‡å®šæµç¨‹å¤±è´¥: {}", e);
                    let mut progress = progress_arc.lock().unwrap();
                    progress.current_stage = CalibrationStage::Error(e);
                }
            }
            
            running_arc.store(false, Ordering::SeqCst);
        });
        
        println!("âœ… æ ‡å®šè®¡ç®—æµç¨‹å·²å¯åŠ¨");
        Ok(())
    }
    
    /// åå°è¿è¡Œæ ‡å®šæµç¨‹
    fn run_calibration_background(
        captured_images: Vec<ImagePair>,
        system_config: SystemConfig,
        progress_arc: Arc<Mutex<CalibrationProgress>>,
        running_arc: Arc<AtomicBool>,
    ) -> Result<CalibrationResult, String> {
        
        // é˜¶æ®µ1: åŠ è½½å›¾åƒå’Œæ£€æµ‹ç‰¹å¾ç‚¹
        {
            let mut progress = progress_arc.lock().unwrap();
            progress.current_stage = CalibrationStage::LoadingImages;
            progress.progress_percentage = 10.0;
            progress.stage_description = "æ­£åœ¨åŠ è½½æ ‡å®šå›¾åƒ...".to_string();
            progress.estimated_remaining_time = 45;
            progress.total_images = captured_images.len() as u32;
        }
        
        let valid_images: Vec<_> = captured_images.iter()
            .filter(|img| img.is_valid)
            .collect();
        
        // é‡æ–°åˆ›å»ºæ ‡å®šå™¨
        let (diameter, center_distance, pattern_size) = system_config.get_effective_pattern_params();
        let image_size = Size::new(2448, 2048); // ä½¿ç”¨é»˜è®¤åˆ†è¾¨ç‡
        
        let mut calibrator = Calibrator::new(
            image_size,
            diameter,
            center_distance,
            pattern_size,
            2.0, // é‡æŠ•å½±è¯¯å·®é˜ˆå€¼
        ).map_err(|e| format!("åˆ›å»ºæ ‡å®šå™¨å¤±è´¥: {}", e))?;
        
        let (left_obj_points, left_img_points, right_obj_points, right_img_points) = 
            Self::load_and_detect_features(&mut calibrator, &valid_images, &progress_arc)?;
        
        if !running_arc.load(Ordering::SeqCst) {
            return Err("æ ‡å®šæµç¨‹è¢«å–æ¶ˆ".to_string());
        }
        
        // é˜¶æ®µ2: å·¦ç›¸æœºå•ç›®æ ‡å®š
        {
            let mut progress = progress_arc.lock().unwrap();
            progress.current_stage = CalibrationStage::LeftMonoCalibration;
            progress.progress_percentage = 30.0;
            progress.stage_description = "æ­£åœ¨è¿›è¡Œå·¦ç›¸æœºæ ‡å®š...".to_string();
            progress.estimated_remaining_time = 35;
        }
        
        let left_result = calibrator.calibrate_mono(&left_obj_points, &left_img_points)
            .map_err(|e| format!("å·¦ç›¸æœºæ ‡å®šå¤±è´¥: {}", e))?;
        
        let (left_camera_matrix, left_dist_coeffs, left_rms_error) = match left_result {
            MonoCalibResult::Success { camera_matrix, dist_coeffs, error } => {
                (camera_matrix, dist_coeffs, error)
            }
            MonoCalibResult::NeedRecalibration(error) => {
                return Err(format!("å·¦ç›¸æœºæ ‡å®šç²¾åº¦ä¸è¶³: RMS = {:.3}", error));
            }
        };
        
        if !running_arc.load(Ordering::SeqCst) {
            return Err("æ ‡å®šæµç¨‹è¢«å–æ¶ˆ".to_string());
        }
        
        // é˜¶æ®µ3: å³ç›¸æœºå•ç›®æ ‡å®š
        {
            let mut progress = progress_arc.lock().unwrap();
            progress.current_stage = CalibrationStage::RightMonoCalibration;
            progress.progress_percentage = 50.0;
            progress.stage_description = "æ­£åœ¨è¿›è¡Œå³ç›¸æœºæ ‡å®š...".to_string();
            progress.estimated_remaining_time = 25;
        }
        
        let right_result = calibrator.calibrate_mono(&right_obj_points, &right_img_points)
            .map_err(|e| format!("å³ç›¸æœºæ ‡å®šå¤±è´¥: {}", e))?;
        
        let (right_camera_matrix, right_dist_coeffs, right_rms_error) = match right_result {
            MonoCalibResult::Success { camera_matrix, dist_coeffs, error } => {
                (camera_matrix, dist_coeffs, error)
            }
            MonoCalibResult::NeedRecalibration(error) => {
                return Err(format!("å³ç›¸æœºæ ‡å®šç²¾åº¦ä¸è¶³: RMS = {:.3}", error));
            }
        };
        
        if !running_arc.load(Ordering::SeqCst) {
            return Err("æ ‡å®šæµç¨‹è¢«å–æ¶ˆ".to_string());
        }
        
        // é˜¶æ®µ4: åŒç›®æ ‡å®š
        {
            let mut progress = progress_arc.lock().unwrap();
            progress.current_stage = CalibrationStage::StereoCalibration;
            progress.progress_percentage = 70.0;
            progress.stage_description = "æ­£åœ¨è¿›è¡ŒåŒç›®æ ‡å®š...".to_string();
            progress.estimated_remaining_time = 15;
        }
        
        let left_mono = MonoCamera { 
            camera_matrix: left_camera_matrix.clone(), 
            dist_coeffs: left_dist_coeffs.clone() 
        };
        let right_mono = MonoCamera { 
            camera_matrix: right_camera_matrix.clone(), 
            dist_coeffs: right_dist_coeffs.clone() 
        };
        
        let stereo_result = calibrator.calibrate_stereo(
            &left_obj_points,
            &left_img_points,
            &right_img_points,
            &left_mono,
            &right_mono,
        ).map_err(|e| format!("åŒç›®æ ‡å®šå¤±è´¥: {}", e))?;
        
        let (r_matrix, t_vector, stereo_rms_error) = match stereo_result {
            StereoCalibResult::Success { r, t, error } => (r, t, error),
            StereoCalibResult::NeedRecalibration(error) => {
                return Err(format!("åŒç›®æ ‡å®šç²¾åº¦ä¸è¶³: RMS = {:.3}", error));
            }
        };
        
        if !running_arc.load(Ordering::SeqCst) {
            return Err("æ ‡å®šæµç¨‹è¢«å–æ¶ˆ".to_string());
        }
        
        // é˜¶æ®µ5: è®¡ç®—é‡æ˜ å°„çŸ©é˜µ
        {
            let mut progress = progress_arc.lock().unwrap();
            progress.current_stage = CalibrationStage::ComputingRectification;
            progress.progress_percentage = 85.0;
            progress.stage_description = "æ­£åœ¨è®¡ç®—é‡æ˜ å°„çŸ©é˜µ...".to_string();
            progress.estimated_remaining_time = 8;
        }
        
        let rectify_maps = calibrator.compute_stereo_rectify(
            &left_mono,
            &right_mono,
            &r_matrix,
            &t_vector,
        ).map_err(|e| format!("è®¡ç®—é‡æ˜ å°„çŸ©é˜µå¤±è´¥: {}", e))?;
        
        let (left_map1, left_map2) = calibrator.compute_undistort_maps(
            &left_camera_matrix,
            &left_dist_coeffs,
            &rectify_maps.r1,
            &rectify_maps.p1,
        ).map_err(|e| format!("è®¡ç®—å·¦ç›¸æœºé‡æ˜ å°„å¤±è´¥: {}", e))?;
        
        let (right_map1, right_map2) = calibrator.compute_undistort_maps(
            &right_camera_matrix,
            &right_dist_coeffs,
            &rectify_maps.r2,
            &rectify_maps.p2,
        ).map_err(|e| format!("è®¡ç®—å³ç›¸æœºé‡æ˜ å°„å¤±è´¥: {}", e))?;
        
        if !running_arc.load(Ordering::SeqCst) {
            return Err("æ ‡å®šæµç¨‹è¢«å–æ¶ˆ".to_string());
        }
        
        // é˜¶æ®µ6: éªŒè¯å’Œä¿å­˜ç»“æœ
        {
            let mut progress = progress_arc.lock().unwrap();
            progress.current_stage = CalibrationStage::ValidatingResults;
            progress.progress_percentage = 95.0;
            progress.stage_description = "æ­£åœ¨éªŒè¯æ ‡å®šç»“æœ...".to_string();
            progress.estimated_remaining_time = 3;
        }
        
        let quality = Self::assess_calibration_quality(
            left_rms_error, right_rms_error, stereo_rms_error, valid_images.len()
        );
        
        // ä¿å­˜æ ‡å®šå‚æ•°
        {
            let mut progress = progress_arc.lock().unwrap();
            progress.current_stage = CalibrationStage::SavingParameters;
            progress.progress_percentage = 98.0;
            progress.stage_description = "æ­£åœ¨ä¿å­˜æ ‡å®šå‚æ•°...".to_string();
            progress.estimated_remaining_time = 1;
        }
        
        let saved_files = Self::save_calibration_parameters(
            &system_config,
            &left_camera_matrix, &left_dist_coeffs,
            &right_camera_matrix, &right_dist_coeffs,
            &r_matrix, &t_vector,
            &rectify_maps,
            &left_map1, &left_map2,
            &right_map1, &right_map2,
        )?;
        
        // æ ‡å®šå®Œæˆ
        {
            let mut progress = progress_arc.lock().unwrap();
            progress.current_stage = CalibrationStage::Completed;
            progress.progress_percentage = 100.0;
            progress.stage_description = "æ ‡å®šå®Œæˆï¼".to_string();
            progress.estimated_remaining_time = 0;
        }
        
        let result = CalibrationResult {
            success: true,
            left_rms_error,
            right_rms_error,
            stereo_rms_error,
            error_threshold: 2.0,
            error_message: None,
            saved_files,
            quality: Some(quality),
            calibration_time: chrono::Utc::now().to_rfc3339(),
        };
        
        Ok(result)
    }
    
    /// åŠ è½½å›¾åƒå¹¶æ£€æµ‹ç‰¹å¾ç‚¹
    fn load_and_detect_features(
        calibrator: &mut Calibrator,
        images: &[&ImagePair],
        progress_arc: &Arc<Mutex<CalibrationProgress>>,
    ) -> Result<(Vector<Vector<Point3f>>, Vector<Vector<Point2f>>, 
                Vector<Vector<Point3f>>, Vector<Vector<Point2f>>), String> {
        
        let mut left_obj_points = Vector::new();
        let mut left_img_points = Vector::new();
        let mut right_obj_points = Vector::new();
        let mut right_img_points = Vector::new();
        
        for (i, image_pair) in images.iter().enumerate() {
            {
                let mut progress = progress_arc.lock().unwrap();
                progress.current_stage = CalibrationStage::DetectingFeatures;
                progress.progress_percentage = 10.0 + (i as f32 / images.len() as f32) * 15.0;
                progress.stage_description = format!("æ­£åœ¨æ£€æµ‹ç¬¬ {}/{} ç»„å›¾åƒç‰¹å¾ç‚¹...", i + 1, images.len());
                progress.processed_images = i as u32;
            }
            
            // åŠ è½½å·¦å›¾åƒ
            let left_image = imgcodecs::imread(&image_pair.left_image_path, imgcodecs::IMREAD_GRAYSCALE)
                .map_err(|e| format!("åŠ è½½å·¦å›¾åƒå¤±è´¥ {}: {}", image_pair.left_image_path, e))?;
            
            // åŠ è½½å³å›¾åƒ
            let right_image = imgcodecs::imread(&image_pair.right_image_path, imgcodecs::IMREAD_GRAYSCALE)
                .map_err(|e| format!("åŠ è½½å³å›¾åƒå¤±è´¥ {}: {}", image_pair.right_image_path, e))?;
            
            // æ£€æµ‹å·¦å›¾åƒç‰¹å¾ç‚¹
            let left_corners = calibrator.find_asymmetric_circles_grid_points(&left_image, false)
                .map_err(|e| format!("å·¦å›¾åƒç‰¹å¾ç‚¹æ£€æµ‹å¤±è´¥: {}", e))?;
            
            // æ£€æµ‹å³å›¾åƒç‰¹å¾ç‚¹
            let right_corners = calibrator.find_asymmetric_circles_grid_points(&right_image, false)
                .map_err(|e| format!("å³å›¾åƒç‰¹å¾ç‚¹æ£€æµ‹å¤±è´¥: {}", e))?;
            
            if left_corners.len() > 0 && right_corners.len() > 0 {
                // ç”Ÿæˆä¸–ç•Œåæ ‡ç‚¹
                let obj_points = calibrator.generate_world_points_from_list()
                    .map_err(|e| format!("ç”Ÿæˆä¸–ç•Œåæ ‡å¤±è´¥: {}", e))?;
                
                left_obj_points.push(obj_points.clone());
                left_img_points.push(left_corners);
                right_obj_points.push(obj_points);
                right_img_points.push(right_corners);
            }
        }
        
        if left_img_points.len() < 8 {
            return Err(format!("æ£€æµ‹åˆ°çš„æœ‰æ•ˆç‰¹å¾ç‚¹ç»„æ•°ä¸è¶³: {}/8", left_img_points.len()));
        }
        
        println!("âœ… ç‰¹å¾ç‚¹æ£€æµ‹å®Œæˆï¼Œæœ‰æ•ˆç»„æ•°: {}", left_img_points.len());
        Ok((left_obj_points, left_img_points, right_obj_points, right_img_points))
    }
    
    /// è¯„ä¼°æ ‡å®šè´¨é‡
    fn assess_calibration_quality(
        left_rms: f64,
        right_rms: f64,
        stereo_rms: f64,
        image_count: usize,
    ) -> CalibrationQuality {
        
        // è¯„ä¼°æ€»ä½“ç­‰çº§
        let max_rms = left_rms.max(right_rms).max(stereo_rms);
        let overall_grade = match max_rms {
            x if x < 0.5 => QualityGrade::Excellent,
            x if x < 1.0 => QualityGrade::Good,
            x if x < 2.0 => QualityGrade::Acceptable,
            _ => QualityGrade::Poor,
        };
        
        // ç”Ÿæˆæ”¹è¿›å»ºè®®
        let mut recommendations = Vec::new();
        
        if max_rms > 1.0 {
            recommendations.push("é‡æŠ•å½±è¯¯å·®è¾ƒå¤§ï¼Œå»ºè®®é‡æ–°é‡‡é›†æ ‡å®šå›¾åƒ".to_string());
        }
        
        if image_count < 12 {
            recommendations.push("å»ºè®®å¢åŠ æ›´å¤šæ ‡å®šå›¾åƒä»¥æé«˜ç²¾åº¦".to_string());
        }
        
        if left_rms > 1.5 || right_rms > 1.5 {
            recommendations.push("å»ºè®®ç¡®ä¿æ ‡å®šæ¿åœ¨å›¾åƒä¸­æ¸…æ™°å¯è§ï¼Œé¿å…æ¨¡ç³Šå’Œé®æŒ¡".to_string());
        }
        
        if stereo_rms > 1.5 {
            recommendations.push("åŒç›®æ ‡å®šè¯¯å·®è¾ƒå¤§ï¼Œå»ºè®®æ£€æŸ¥å·¦å³ç›¸æœºåŒæ­¥æ€§".to_string());
        }
        
        if overall_grade == QualityGrade::Excellent {
            recommendations.push("æ ‡å®šè´¨é‡ä¼˜ç§€ï¼Œå¯ä»¥æŠ•å…¥ä½¿ç”¨".to_string());
        }
        
        CalibrationQuality {
            overall_grade,
            left_camera_quality: CameraQuality {
                rms_error: left_rms,
                max_error: left_rms * 1.5,
                mean_error: left_rms * 0.8,
                coverage_score: 85.0, // ç®€åŒ–è¯„ä¼°
                angle_diversity: 80.0,
            },
            right_camera_quality: CameraQuality {
                rms_error: right_rms,
                max_error: right_rms * 1.5,
                mean_error: right_rms * 0.8,
                coverage_score: 85.0,
                angle_diversity: 80.0,
            },
            stereo_quality: StereoQuality {
                stereo_rms_error: stereo_rms,
                epipolar_error: stereo_rms * 0.9,
                baseline_accuracy: 95.0,
            },
            recommendations,
        }
    }
    
    /// ä¿å­˜æ ‡å®šå‚æ•°åˆ°æ–‡ä»¶
    fn save_calibration_parameters(
        system_config: &SystemConfig,
        left_camera_matrix: &Mat, left_dist_coeffs: &Mat,
        right_camera_matrix: &Mat, right_dist_coeffs: &Mat,
        r_matrix: &Mat, t_vector: &Mat,
        rectify_maps: &crate::modules::calibration_circles::RectifyMaps,
        left_map1: &Mat, left_map2: &Mat,
        right_map1: &Mat, right_map2: &Mat,
    ) -> Result<CalibrationFiles, String> {
        
        // ä¿å­˜å·¦ç›¸æœºå‚æ•°
        let left_params = CameraParams {
            camera_matrix: mat_to_vec2d_f64(left_camera_matrix),
            dist_coeffs: mat_to_vec_f64(left_dist_coeffs),
        };
        save_camera_params(&system_config.file_paths.left_camera_params_path, &left_params)
            .map_err(|e| format!("ä¿å­˜å·¦ç›¸æœºå‚æ•°å¤±è´¥: {}", e))?;
        
        // ä¿å­˜å³ç›¸æœºå‚æ•°
        let right_params = CameraParams {
            camera_matrix: mat_to_vec2d_f64(right_camera_matrix),
            dist_coeffs: mat_to_vec_f64(right_dist_coeffs),
        };
        save_camera_params(&system_config.file_paths.right_camera_params_path, &right_params)
            .map_err(|e| format!("ä¿å­˜å³ç›¸æœºå‚æ•°å¤±è´¥: {}", e))?;
        
        // ä¿å­˜åŒç›®å‚æ•°
        let stereo_params = StereoParams {
            r: mat_to_vec2d_f64(r_matrix),
            t: mat_to_vec_f64(t_vector),
        };
        save_stereo_params(&system_config.file_paths.stereo_params_path, &stereo_params)
            .map_err(|e| format!("ä¿å­˜åŒç›®å‚æ•°å¤±è´¥: {}", e))?;
        
        // ä¿å­˜é‡æ˜ å°„å‚æ•°
        let rectify_params = RectifyParams {
            r1: mat_to_vec2d_f64(&rectify_maps.r1),
            r2: mat_to_vec2d_f64(&rectify_maps.r2),
            p1: mat_to_vec2d_f64(&rectify_maps.p1),
            p2: mat_to_vec2d_f64(&rectify_maps.p2),
            q: mat_to_vec2d_f64(&rectify_maps.q),
        };
        save_rectify_params(&system_config.file_paths.rectify_params_path, &rectify_params)
            .map_err(|e| format!("ä¿å­˜é‡æ˜ å°„å‚æ•°å¤±è´¥: {}", e))?;
        
        // ä¿å­˜é‡æ˜ å°„çŸ©é˜µ
        let rectify_lr_maps = RectifyLeftRightMaps {
            left_map1: mat_to_vec2d_f32(left_map1),
            left_map2: mat_to_vec2d_f32(left_map2),
            right_map1: mat_to_vec2d_f32(right_map1),
            right_map2: mat_to_vec2d_f32(right_map2),
        };
        save_rectify_maps(&system_config.file_paths.rectify_maps_path, &rectify_lr_maps)
            .map_err(|e| format!("ä¿å­˜é‡æ˜ å°„çŸ©é˜µå¤±è´¥: {}", e))?;
        
        println!("âœ… æ‰€æœ‰æ ‡å®šå‚æ•°å·²ä¿å­˜");
        
        Ok(CalibrationFiles {
            left_camera_params: Some(system_config.file_paths.left_camera_params_path.clone()),
            right_camera_params: Some(system_config.file_paths.right_camera_params_path.clone()),
            stereo_params: Some(system_config.file_paths.stereo_params_path.clone()),
            rectify_params: Some(system_config.file_paths.rectify_params_path.clone()),
            rectify_maps: Some(system_config.file_paths.rectify_maps_path.clone()),
        })
    }
    
    /// å–æ¶ˆæ ‡å®šæµç¨‹
    pub fn cancel_calibration(&mut self) -> Result<(), String> {
        if !self.calibration_running.load(Ordering::SeqCst) {
            return Ok(()); // æ²¡æœ‰è¿è¡Œä¸­çš„æ ‡å®š
        }
        
        println!("â¹ï¸ å–æ¶ˆæ ‡å®šæµç¨‹...");
        self.calibration_running.store(false, Ordering::SeqCst);
        
        // é‡ç½®è¿›åº¦
        let mut progress = self.calibration_progress.lock().unwrap();
        progress.current_stage = CalibrationStage::Idle;
        progress.progress_percentage = 0.0;
        progress.stage_description = "æ ‡å®šå·²å–æ¶ˆ".to_string();
        progress.estimated_remaining_time = 0;
        
        println!("âœ… æ ‡å®šæµç¨‹å·²å–æ¶ˆ");
        Ok(())
    }
    
    /// å¤„ç†æ ‡å®šé”™è¯¯å¹¶ç”Ÿæˆç”¨æˆ·æŒ‡å¯¼
    pub fn handle_calibration_error(&self, error: CalibrationError) -> UserGuidance {
        match error {
            CalibrationError::InsufficientImages => UserGuidance {
                title: "å›¾åƒæ•°é‡ä¸è¶³".to_string(),
                message: "éœ€è¦è‡³å°‘8ç»„æœ‰æ•ˆçš„æ ‡å®šå›¾åƒæ‰èƒ½è¿›è¡Œæ ‡å®š".to_string(),
                actions: vec![
                    "ç»§ç»­é‡‡é›†æ›´å¤šæ ‡å®šå›¾åƒ".to_string(),
                    "ç¡®ä¿æ ‡å®šæ¿åœ¨æ¯å¼ å›¾åƒä¸­éƒ½æ¸…æ™°å¯è§".to_string(),
                    "å°è¯•ä¸åŒçš„è§’åº¦å’Œä½ç½®æ‹æ‘„".to_string(),
                ],
                can_retry: true,
            },
            CalibrationError::FeatureDetectionFailed => UserGuidance {
                title: "ç‰¹å¾ç‚¹æ£€æµ‹å¤±è´¥".to_string(),
                message: "æ— æ³•åœ¨å›¾åƒä¸­æ£€æµ‹åˆ°æ ‡å®šæ¿ç‰¹å¾ç‚¹".to_string(),
                actions: vec![
                    "ç¡®ä¿æ ‡å®šæ¿å®Œå…¨åœ¨å›¾åƒèŒƒå›´å†…".to_string(),
                    "æ£€æŸ¥å›¾åƒæ¸…æ™°åº¦ï¼Œé¿å…æ¨¡ç³Š".to_string(),
                    "ç¡®ä¿å…‰ç…§å……è¶³ä¸”å‡åŒ€".to_string(),
                    "æ£€æŸ¥æ ‡å®šæ¿æ˜¯å¦æœ‰æŸåæˆ–æ±¡æ¸".to_string(),
                ],
                can_retry: true,
            },
            CalibrationError::HighReprojectionError => UserGuidance {
                title: "æ ‡å®šç²¾åº¦ä¸è¶³".to_string(),
                message: "é‡æŠ•å½±è¯¯å·®è¿‡å¤§ï¼Œæ ‡å®šè´¨é‡ä¸ç¬¦åˆè¦æ±‚".to_string(),
                actions: vec![
                    "ç¡®ä¿æ ‡å®šæ¿å®Œå…¨å¹³æ•´ï¼Œæ— å¼¯æ›²å˜å½¢".to_string(),
                    "å¢åŠ ä¸åŒè§’åº¦å’Œä½ç½®çš„æ ‡å®šå›¾åƒ".to_string(),
                    "ç¡®ä¿æ ‡å®šæ¿åœ¨å›¾åƒä¸­æ¸…æ™°å¯è§".to_string(),
                    "é¿å…æ ‡å®šæ¿åå…‰æˆ–é˜´å½±é®æŒ¡".to_string(),
                    "æ£€æŸ¥ç›¸æœºå›ºå®šæ˜¯å¦ç¨³å®š".to_string(),
                ],
                can_retry: true,
            },
            CalibrationError::CalibrationFailed => UserGuidance {
                title: "æ ‡å®šç®—æ³•å¤±è´¥".to_string(),
                message: "æ ‡å®šç®—æ³•è®¡ç®—å¤±è´¥ï¼Œå¯èƒ½æ˜¯è¾“å…¥æ•°æ®æœ‰é—®é¢˜".to_string(),
                actions: vec![
                    "æ£€æŸ¥æ‰€æœ‰å›¾åƒæ˜¯å¦æ­£ç¡®åŠ è½½".to_string(),
                    "é‡æ–°é‡‡é›†æ ‡å®šå›¾åƒ".to_string(),
                    "ç¡®ä¿å·¦å³ç›¸æœºå›¾åƒæ­£ç¡®é…å¯¹".to_string(),
                    "è”ç³»æŠ€æœ¯æ”¯æŒ".to_string(),
                ],
                can_retry: true,
            },
            CalibrationError::FileSystemError => UserGuidance {
                title: "æ–‡ä»¶ç³»ç»Ÿé”™è¯¯".to_string(),
                message: "æ— æ³•è¯»å–æˆ–å†™å…¥æ ‡å®šæ–‡ä»¶".to_string(),
                actions: vec![
                    "æ£€æŸ¥æ–‡ä»¶è·¯å¾„æ˜¯å¦æ­£ç¡®".to_string(),
                    "ç¡®ä¿æœ‰è¶³å¤Ÿçš„ç£ç›˜ç©ºé—´".to_string(),
                    "æ£€æŸ¥æ–‡ä»¶æƒé™è®¾ç½®".to_string(),
                    "é‡å¯åº”ç”¨ç¨‹åº".to_string(),
                ],
                can_retry: true,
            },
            CalibrationError::ConfigurationError => UserGuidance {
                title: "é…ç½®é”™è¯¯".to_string(),
                message: "ç³»ç»Ÿé…ç½®æœ‰è¯¯ï¼Œæ— æ³•è¿›è¡Œæ ‡å®š".to_string(),
                actions: vec![
                    "æ£€æŸ¥ç³»ç»Ÿé…ç½®æ–‡ä»¶".to_string(),
                    "é‡ç½®ä¸ºé»˜è®¤é…ç½®".to_string(),
                    "è”ç³»æŠ€æœ¯æ”¯æŒ".to_string(),
                ],
                can_retry: false,
            },
            CalibrationError::CameraError => UserGuidance {
                title: "ç›¸æœºæ“ä½œé”™è¯¯".to_string(),
                message: "ç›¸æœºæ“ä½œå¤±è´¥ï¼Œæ— æ³•é‡‡é›†å›¾åƒ".to_string(),
                actions: vec![
                    "æ£€æŸ¥ç›¸æœºè¿æ¥".to_string(),
                    "é‡å¯ç›¸æœº".to_string(),
                    "æ£€æŸ¥ç›¸æœºé©±åŠ¨".to_string(),
                    "è”ç³»æŠ€æœ¯æ”¯æŒ".to_string(),
                ],
                can_retry: true,
            },
        }
    }
}

impl Default for CaptureConfig {
    fn default() -> Self {
        Self {
            preview_fps: 10,
            capture_resolution: (2448, 2048),
            thumbnail_size: (200, 166),
            save_directory: "calibration_images".to_string(),
            image_format: "png".to_string(),
        }
    }
} 