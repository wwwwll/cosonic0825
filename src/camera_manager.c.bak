/**
 * @file camera_manager.c
 * @brief C层统一相机管理器 - 统一入口和资源管理
 * 
 * 基于重构计划，将现有的分散C文件功能整合为统一管理器，
 * 提供给Rust层统一的FFI接口。
 * 
 * 核心功能:
 * 1. 统一的相机初始化和释放
 * 2. 配置文件加载和参数应用
 * 3. 工作流程阶段管理
 * 4. 统一的图像采集接口 (连续/单帧)
 * 5. 性能监控和状态管理
 * 6. 错误处理和资源保护
 * 
 * @version 1.0
 * @date 2025/01/15
 * @author Camera Architecture Refactor Expert
 */

#include <stdio.h>
#include <string.h>
#include <stdint.h>
//#include <stdlib.h>
#include <time.h>
#include "MvCameraControl.h"
#include "MvErrorDefine.h"
#include "CameraParams.h"
#include "MvISPErrorDefine.h"
#include "MvSdkExport.h"
#include "PixelType.h"
#include "camera_api.h"

// 定义bool类型，避免与海康SDK头文件冲突
#ifndef bool
#define bool int
#define true 1
#define false 0
#endif

// ==================== 内部状态管理 ====================

// 管理器状态枚举
typedef enum {
    MANAGER_STATE_UNINITIALIZED = 0,
    MANAGER_STATE_INITIALIZED = 1,
    MANAGER_STATE_CONFIGURED = 2,
    MANAGER_STATE_STARTED = 3,
    MANAGER_STATE_ERROR = -1
} ManagerState;

// 当前工作流程阶段
typedef enum {
    STAGE_PREVIEW = 0,
    STAGE_DETECTION = 1,
    STAGE_ALIGNMENT = 2,
    STAGE_UNKNOWN = -1
} CurrentStage;

// 管理器全局状态
static struct {
    ManagerState state;
    CurrentStage current_stage;
    char config_file_path[256];
    bool cameras_started;
    uint64_t frame_counter;
    uint32_t error_counter;
    time_t last_status_check;
} g_manager = {
    .state = MANAGER_STATE_UNINITIALIZED,
    .current_stage = STAGE_UNKNOWN,
    .config_file_path = {0},
    .cameras_started = false,
    .frame_counter = 0,
    .error_counter = 0,
    .last_status_check = 0
};

// ==================== 内部辅助函数 ====================

/**
 * @brief 验证管理器状态
 */
static bool validate_manager_state(const char* func_name, ManagerState required_state) {
    if (g_manager.state < required_state) {
        printf("ERROR %s: 管理器状态不正确，当前: %d，需要: %d\n", func_name, g_manager.state, required_state);
        return false;
    }
    return true;
}

/**
 * @brief 解析阶段名称
 */
static CurrentStage parse_stage_name(const char* stage_name) {
    if (!stage_name) return STAGE_UNKNOWN;
    
    if (strcmp(stage_name, "preview") == 0) return STAGE_PREVIEW;
    if (strcmp(stage_name, "detection") == 0) return STAGE_DETECTION;
    if (strcmp(stage_name, "alignment") == 0) return STAGE_ALIGNMENT;
    
    return STAGE_UNKNOWN;
}

/**
 * @brief 获取阶段名称字符串
 */
static const char* get_stage_name(CurrentStage stage) {
    switch (stage) {
        case STAGE_PREVIEW: return "preview";
        case STAGE_DETECTION: return "detection";
        case STAGE_ALIGNMENT: return "alignment";
        default: return "unknown";
    }
}

// ==================== 公共API实现 ====================

/**
 * @brief 初始化相机管理器
 * @param config_file_path 配置文件路径 (可选，传NULL使用默认配置)
 * @return 错误码 (0=成功)
 */
int camera_manager_init(const char* config_file_path) {
    const char* func_name = "camera_manager_init";
    int ret = 0;
    
    printf("INFO %s: 开始初始化相机管理器...\n", func_name);
    
    // 1. 重置管理器状态
    memset(&g_manager, 0, sizeof(g_manager));
    g_manager.state = MANAGER_STATE_UNINITIALIZED;
    g_manager.current_stage = STAGE_UNKNOWN;
    
    // 2. 保存配置文件路径
    if (config_file_path) {
        strncpy(g_manager.config_file_path, config_file_path, sizeof(g_manager.config_file_path) - 1);
        printf("INFO %s: 配置文件路径: %s\n", func_name, config_file_path);
    }
    
    // 3. 调用原有的camera_init进行底层初始化
    ret = camera_init();
    if (ret != MV_OK) {
        printf("ERROR %s: 底层相机初始化失败: 0x%x\n", func_name, ret);
        g_manager.state = MANAGER_STATE_ERROR;
        g_manager.error_counter++;
        return ret;
    }
    
    // 4. 更新状态
    g_manager.state = MANAGER_STATE_INITIALIZED;
    g_manager.last_status_check = time(NULL);
    
    // 5. 如果有配置文件，自动加载配置
    if (config_file_path) {
        ret = camera_manager_configure(config_file_path);
        if (ret != MV_OK) {
            printf("WARN %s: 配置加载失败，但初始化继续: 0x%x\n", func_name, ret);
            // 配置失败不影响初始化成功
        }
    }
    
    printf("INFO %s: 相机管理器初始化完成\n", func_name);
    return MV_OK;
}

/**
 * @brief 从配置文件重新加载配置
 * @param config_file_path 配置文件路径
 * @return 错误码 (0=成功)
 */
int camera_manager_configure(const char* config_file_path) {
    const char* func_name = "camera_manager_configure";
    
    if (!validate_manager_state(func_name, MANAGER_STATE_INITIALIZED)) {
        return -1;
    }
    
    printf("INFO %s: 开始加载配置文件: %s\n", func_name, config_file_path ? config_file_path : "NULL");
    
    // TODO: 实现配置文件加载逻辑
    // 当前暂时跳过配置文件加载，使用默认参数
    // 后续需要集成 src-tauri/src/config/ 模块
    
    // 1. 设置默认参数
    int ret = MV_OK;
    for (unsigned int i = 0; i < CAMERA_NUM; i++) {
        if (!cameras[i].opened) continue;
        
        // 设置默认帧率为15fps
        ret = camera_set_frame_rate(i, 15);
        if (ret != MV_OK) {
            printf("WARN %s: 设置相机 %d 帧率失败: 0x%x\n", func_name, i, ret);
        }
        
        // 设置默认为连续模式
        ret = camera_set_trigger_mode(i, TRIGGER_OFF);
        if (ret != MV_OK) {
            printf("WARN %s: 设置相机 %d 触发模式失败: 0x%x\n", func_name, i, ret);
        }
    }
    
    // 2. 更新状态
    if (config_file_path) {
        strncpy(g_manager.config_file_path, config_file_path, sizeof(g_manager.config_file_path) - 1);
    }
    g_manager.state = MANAGER_STATE_CONFIGURED;
    
    printf("INFO %s: 配置加载完成\n", func_name);
    return MV_OK;
}

/**
 * @brief 启动相机管理器
 * @return 错误码 (0=成功)
 */
int camera_manager_start() {
    const char* func_name = "camera_manager_start";
    
    if (!validate_manager_state(func_name, MANAGER_STATE_INITIALIZED)) {
        return -1;
    }
    
    printf("INFO %s: 启动相机管理器...\n", func_name);
    
    // 1. 调用底层相机启动
    int ret = camera_start();
    if (ret != MV_OK) {
        printf("ERROR %s: 底层相机启动失败: 0x%x\n", func_name, ret);
        g_manager.state = MANAGER_STATE_ERROR;
        g_manager.error_counter++;
        return ret;
    }
    
    // 2. 更新状态
    g_manager.cameras_started = true;
    g_manager.state = MANAGER_STATE_STARTED;
    g_manager.frame_counter = 0;
    
    printf("INFO %s: 相机管理器启动成功\n", func_name);
    return MV_OK;
}

/**
 * @brief 设置工作流程阶段
 * @param stage_name 阶段名称 ("preview", "detection", "alignment")
 * @return 错误码 (0=成功)
 */
int camera_manager_set_stage(const char* stage_name) {
    const char* func_name = "camera_manager_set_stage";
    
    if (!validate_manager_state(func_name, MANAGER_STATE_INITIALIZED)) {
        return -1;
    }
    
    if (!stage_name) {
        printf("ERROR %s: 阶段名称不能为空\n", func_name);
        return -1;
    }
    
    CurrentStage new_stage = parse_stage_name(stage_name);
    if (new_stage == STAGE_UNKNOWN) {
        printf("ERROR %s: 未知的阶段名称: %s\n", func_name, stage_name);
        return -1;
    }
    
    if (g_manager.current_stage == new_stage) {
        printf("INFO %s: 阶段未变化，跳过: %s\n", func_name, stage_name);
        return MV_OK;
    }
    
    printf("INFO %s: 切换阶段: %s -> %s\n", func_name, get_stage_name(g_manager.current_stage), stage_name);
    
    // 使用配置系统应用阶段参数，而不是写死参数
    int ret = camera_config_apply_stage_params(stage_name);
    if (ret != MV_OK) {
        printf("ERROR %s: 应用阶段 %s 配置失败: 0x%x\n", func_name, stage_name, ret);
        return ret;
    }
    
    // 更新管理器状态
    g_manager.current_stage = new_stage;
    
    printf("INFO %s: 阶段切换完成: %s\n", func_name, stage_name);
    return MV_OK;
}

/**
 * @brief 连续采集模式
 * @param out_bufs 输出缓冲区数组 [左相机, 右相机]
 * @param out_sizes 输出尺寸数组 [左相机尺寸, 右相机尺寸]
 * @return 错误码 (0=成功)
 */
int camera_manager_capture_continuous(uint8_t* out_bufs[], uint32_t out_sizes[]) {
    const char* func_name = "camera_manager_capture_continuous";
    
    if (!validate_manager_state(func_name, MANAGER_STATE_STARTED)) {
        return -1;
    }
    
    if (!out_bufs || !out_sizes) {
        printf("ERROR %s: 输出参数不能为空\n", func_name);
        return -1;
    }
    
    // 调用底层连续采集
    int ret = camera_get_frame(out_bufs, out_sizes);
    if (ret != MV_OK) {
        printf("ERROR %s: 连续采集失败: 0x%x\n", func_name, ret);
        g_manager.error_counter++;
        return ret;
    }
    
    // 更新统计
    g_manager.frame_counter++;
    
    return MV_OK;
}

/**
 * @brief 单帧采集模式 (软触发)
 * @param out_bufs 输出缓冲区数组 [左相机, 右相机]
 * @param out_sizes 输出尺寸数组 [左相机尺寸, 右相机尺寸]
 * @return 错误码 (0=成功)
 */
int camera_manager_capture_single(uint8_t* out_bufs[], uint32_t out_sizes[]) {
    const char* func_name = "camera_manager_capture_single";
    
    if (!validate_manager_state(func_name, MANAGER_STATE_STARTED)) {
        return -1;
    }
    
    if (!out_bufs || !out_sizes) {
        printf("ERROR %s: 输出参数不能为空\n", func_name);
        return -1;
    }
    
    // 调用底层软触发采集
    int ret = camera_software_trigger(out_bufs, out_sizes);
    if (ret != MV_OK) {
        printf("ERROR %s: 单帧采集失败: 0x%x\n", func_name, ret);
        g_manager.error_counter++;
        return ret;
    }
    
    // 更新统计
    g_manager.frame_counter++;
    
    printf("INFO %s: 单帧采集成功，左: %d 字节，右: %d 字节\n", func_name, out_sizes[0], out_sizes[1]);
    
    return MV_OK;
}

/**
 * @brief 获取相机状态和性能统计
 * @param cam_index 相机索引 (0=左, 1=右)
 * @param fps 实际帧率输出
 * @param dropped 丢帧数输出
 * @return 错误码 (0=成功)
 */
int camera_manager_get_status(unsigned int cam_index, float* fps, uint32_t* dropped) {
    const char* func_name = "camera_manager_get_status";
    
    if (!validate_manager_state(func_name, MANAGER_STATE_INITIALIZED)) {
        return -1;
    }
    
    if (cam_index >= CAMERA_NUM) {
        printf("ERROR %s: 无效的相机索引: %d\n", func_name, cam_index);
        return -1;
    }
    
    if (!fps || !dropped) {
        printf("ERROR %s: 输出参数不能为空\n", func_name);
        return -1;
    }
    
    // 调用底层状态获取
    int ret = camera_get_status(cam_index, fps, dropped);
    if (ret != MV_OK) {
        printf("ERROR %s: 获取相机 %d 状态失败: 0x%x\n", func_name, cam_index, ret);
        return ret;
    }
    
    return MV_OK;
}

/**
 * @brief 释放相机管理器资源
 * @return 错误码 (0=成功)
 */
int camera_manager_release() {
    const char* func_name = "camera_manager_release";
    
    printf("INFO %s: 开始释放相机管理器资源...\n", func_name);
    
    // 1. 调用底层释放
    int ret = camera_release();
    if (ret != MV_OK) {
        printf("ERROR %s: 底层相机释放失败: 0x%x\n", func_name, ret);
        // 继续清理状态
    }
    
    // 2. 重置管理器状态
    g_manager.state = MANAGER_STATE_UNINITIALIZED;
    g_manager.current_stage = STAGE_UNKNOWN;
    g_manager.cameras_started = false;
    memset(g_manager.config_file_path, 0, sizeof(g_manager.config_file_path));
    
    printf("INFO %s: 相机管理器资源释放完成，总采集帧数: %llu，错误次数: %u\n", func_name, g_manager.frame_counter, g_manager.error_counter);
    
    return MV_OK;
}

// ==================== 调试和诊断接口 ====================

/**
 * @brief 获取管理器状态信息 (调试用)
 * @return 状态字符串
 */
const char* camera_manager_get_state_info() {
    static char info_buffer[512];
    
    snprintf(info_buffer, sizeof(info_buffer),
             "CameraManager状态:\n"
             "- 管理器状态: %d\n"
             "- 当前阶段: %s\n"
             "- 相机已启动: %s\n"
             "- 配置文件: %s\n"
             "- 总采集帧数: %llu\n"
             "- 错误次数: %u\n",
             g_manager.state,
             get_stage_name(g_manager.current_stage),
             g_manager.cameras_started ? "是" : "否",
             g_manager.config_file_path[0] ? g_manager.config_file_path : "无",
             g_manager.frame_counter,
             g_manager.error_counter);
    
    return info_buffer;
} 